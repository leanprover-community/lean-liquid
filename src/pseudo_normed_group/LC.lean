import category_theory.preadditive.functor_category

import pseudo_normed_group.FP
import locally_constant.SemiNormedGroup
import locally_constant.Vhat

import for_mathlib.normed_group_hom
/-!

# The category of locally constant maps

Various constructions of pseudo-normed groups of locally constant functions.

## Main definitions

- `LC V`: the functor sending a profinite set `S` to the locally constant
  functions from `S` to `V`
- `LCFP V r' c n`: the functor sending a profinitely filtered pseudo-normed
  group with T‚Åª¬π to V(M_c^n), the locally constant functions from M_c^n to V.

-/
namespace category_theory
namespace nat_trans

@[simp] lemma op_comp {C D} [category C] [category D]
  {F G H : C ‚•§ D} {Œ± : F ‚ü∂ G} {Œ≤ : G ‚ü∂ H} :
  nat_trans.op (Œ± ‚â´ Œ≤) = nat_trans.op Œ≤ ‚â´ nat_trans.op Œ± := rfl

end nat_trans
end category_theory

open_locale classical nnreal big_operators
noncomputable theory
local attribute [instance] type_pow

open SemiNormedGroup opposite Profinite pseudo_normed_group category_theory breen_deligne
open profinitely_filtered_pseudo_normed_group

universe variable u
variables (r : ‚Ñù‚â•0) (V : SemiNormedGroup) (r' : ‚Ñù‚â•0)
variables (c c‚ÇÅ c‚ÇÇ c‚ÇÉ c‚ÇÑ : ‚Ñù‚â•0) (l m n : ‚Ñï)

/-- `LC V n` is the functor that sends a profinite set `S` to `V(S)` -/
def LC (V : SemiNormedGroup) : Profinite·µí·µñ ‚•§ SemiNormedGroup :=
LocallyConstant.obj V

namespace LC

lemma map_norm_noninc {M‚ÇÅ M‚ÇÇ} (f : M‚ÇÅ ‚ü∂ M‚ÇÇ) : ((LC V).map f).norm_noninc :=
locally_constant.comap_hom_norm_noninc _ _

instance obj.normed_with_aut [normed_with_aut r V] [fact (0 < r)] (A : Profinite·µí·µñ) :
  normed_with_aut r ((LC V).obj A) :=
SemiNormedGroup.normed_with_aut_LocallyConstant _ _ _

@[simps hom_app_apply inv_app_apply {fully_applied := ff}]
def T [normed_with_aut r V] : LC V ‚âÖ LC V :=
LocallyConstant.map_iso normed_with_aut.T

lemma T_eq [normed_with_aut r V] [fact (0 < r)] (A) :
  (T r V).hom.app A = normed_with_aut.T.hom := rfl

lemma norm_T_le [normed_with_aut r V] [fact (0 < r)] (A) :
  ‚à•(LC.T r V).hom.app A‚à• ‚â§ r :=
begin
  rw T_eq,
  refine normed_group_hom.op_norm_le_bound _ (nnreal.zero_le_coe) (Œª v, _),
  exact le_of_eq (normed_with_aut.norm_T v)
end

@[simps {fully_applied := ff}]
def T_inv [normed_with_aut r V] : LC V ‚ü∂ LC V :=
(LocallyConstant.map (normed_with_aut.T.inv : V ‚ü∂ V) : _)

lemma T_inv_eq [normed_with_aut r V] : (T r V).inv = T_inv r V := rfl

lemma T_inv_eq' [normed_with_aut r V] [fact (0 < r)] (A) :
  (T_inv r V).app A = normed_with_aut.T.inv := rfl

lemma norm_T_inv_le [normed_with_aut r V] [fact (0 < r)] (A) :
  ‚à•(T_inv r V).app A‚à• ‚â§ r‚Åª¬π :=
begin
  rw T_inv_eq',
  refine normed_group_hom.op_norm_le_bound _ (inv_nonneg.2 (nnreal.zero_le_coe)) (Œª v, _),
  exact (normed_with_aut.norm_T_inv _ v).le
end

end LC

/-- The "functor" that sends `M` and `c` to `V((filtration M c)^n)` -/
def LCFP (V : SemiNormedGroup) (r' : ‚Ñù‚â•0) (c : ‚Ñù‚â•0) (n : ‚Ñï) :
  (ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ SemiNormedGroup :=
(FiltrationPow r' c n).op ‚ãô LC V

theorem LCFP_def (V : SemiNormedGroup) (r' : ‚Ñù‚â•0) (c : ‚Ñù‚â•0) (n : ‚Ñï) :
  LCFP V r' c n = (FiltrationPow r' c n).op ‚ãô LocallyConstant.obj V := rfl

namespace LCFP

lemma map_norm_noninc {M‚ÇÅ M‚ÇÇ} (f : M‚ÇÅ ‚ü∂ M‚ÇÇ) : ((LCFP V r' c n).map f).norm_noninc :=
LC.map_norm_noninc _ _

@[simps {fully_applied := ff}]
def res (r' : ‚Ñù‚â•0) (c‚ÇÅ c‚ÇÇ : ‚Ñù‚â•0) [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] (n : ‚Ñï) : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ n :=
(whisker_right (nat_trans.op (FiltrationPow.cast_le r' c‚ÇÇ c‚ÇÅ n)) (LocallyConstant.obj V) : _)

@[simp] lemma res_refl : res V r' c c n = ùüô _ :=
by { simp [res, FiltrationPow.cast_le_refl], refl }

lemma res_comp_res [h‚ÇÅ : fact (c‚ÇÉ ‚â§ c‚ÇÇ)] [h‚ÇÇ : fact (c‚ÇÇ ‚â§ c‚ÇÅ)] :
  res V r' c‚ÇÅ c‚ÇÇ n ‚â´ res V r' c‚ÇÇ c‚ÇÉ n = @res V r' c‚ÇÅ c‚ÇÉ ‚ü®le_trans h‚ÇÅ.1 h‚ÇÇ.1‚ü© n :=
by simp only [res, ‚Üê whisker_right_comp, ‚Üê nat_trans.op_comp, FiltrationPow.cast_le_comp]

lemma res_norm_noninc [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] (M) : ((res V r' c‚ÇÅ c‚ÇÇ n).app M).norm_noninc :=
locally_constant.comap_hom_norm_noninc _ _

section Tinv
open profinitely_filtered_pseudo_normed_group_with_Tinv

@[simps {fully_applied := ff}]
def Tinv [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ n :=
(whisker_right (nat_trans.op $ FiltrationPow.Tinv r' c‚ÇÇ c‚ÇÅ n) (LocallyConstant.obj V) : _)

lemma Tinv_def [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] : Tinv V r' c‚ÇÅ c‚ÇÇ n =
  whisker_right (nat_trans.op $ FiltrationPow.Tinv r' c‚ÇÇ c‚ÇÅ n) (LC V) := rfl

lemma res_comp_Tinv
  [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] [fact (c‚ÇÉ ‚â§ c‚ÇÇ)] [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] [fact (c‚ÇÉ ‚â§ r' * c‚ÇÇ)] :
  res V r' c‚ÇÅ c‚ÇÇ n ‚â´ Tinv V r' c‚ÇÇ c‚ÇÉ n = Tinv V r' c‚ÇÅ c‚ÇÇ n ‚â´ res V r' c‚ÇÇ c‚ÇÉ n :=
begin
  simp only [Tinv, res, ‚Üê whisker_right_comp, ‚Üê nat_trans.op_comp],
  refl
end

lemma Tinv_norm_noninc [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] (M) : ((Tinv V r' c‚ÇÅ c‚ÇÇ n).app M).norm_noninc :=
locally_constant.comap_hom_norm_noninc _ _

end Tinv

section normed_with_aut

variables [normed_with_aut r V]

instance [fact (0 < r)] (M) : normed_with_aut r ((LCFP V r' c n).obj M) :=
LC.obj.normed_with_aut _ _ _

@[simps {fully_applied := ff}]
def T : LCFP V r' c n ‚âÖ LCFP V r' c n :=
((whiskering_left _ _ _).obj _).map_iso $ LC.T r _

@[simps app_apply {fully_applied := ff}]
def T_inv : LCFP V r' c n ‚ü∂ LCFP V r' c n :=
(whisker_left _ (LC.T_inv r V) : _)

lemma T_inv_eq : (T r V r' c n).inv = T_inv r V r' c n := rfl

lemma T_inv_def :
  T_inv r V r' c n = (whisker_left  (FiltrationPow r' c n).op
      (LocallyConstant.map (normed_with_aut.T.inv : V ‚ü∂ V)) : _) :=
rfl

end normed_with_aut

end LCFP

namespace breen_deligne

open LCFP

variables {l m n}

namespace basic_universal_map

variables (œï : basic_universal_map m n)

def eval_LCFP (c‚ÇÅ c‚ÇÇ : ‚Ñù‚â•0) [œï.suitable c‚ÇÇ c‚ÇÅ] : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ m :=
(whisker_right (nat_trans.op $ œï.eval_FP r' c‚ÇÇ c‚ÇÅ) (LocallyConstant.obj V) : _)

def eval_LCFP' (c‚ÇÅ c‚ÇÇ : ‚Ñù‚â•0) : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ m :=
if H : œï.suitable c‚ÇÇ c‚ÇÅ
then by exactI (whisker_right (nat_trans.op $ œï.eval_FP r' c‚ÇÇ c‚ÇÅ) (LocallyConstant.obj V) : _)
else 0

lemma eval_LCFP_eq_eval_LCFP' (h : œï.suitable c‚ÇÇ c‚ÇÅ) :
  œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ = œï.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
by { delta eval_LCFP eval_LCFP', rw dif_pos h }

lemma eval_LCFP'_def [h : œï.suitable c‚ÇÇ c‚ÇÅ] :
  œï.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ =
    (whisker_right (nat_trans.op $ œï.eval_FP r' c‚ÇÇ c‚ÇÅ) (LocallyConstant.obj V) : _) :=
dif_pos h

lemma eval_LCFP'_not_suitable (h : ¬¨ œï.suitable c‚ÇÇ c‚ÇÅ) :
  œï.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ = 0 :=
dif_neg h

lemma eval_LCFP'_comp (f : basic_universal_map m n) (g : basic_universal_map l m)
  [hf : f.suitable c‚ÇÇ c‚ÇÅ] [hg : g.suitable c‚ÇÉ c‚ÇÇ] :
  (basic_universal_map.comp f g).eval_LCFP' V r' c‚ÇÅ c‚ÇÉ = f.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ ‚â´ g.eval_LCFP' V r' c‚ÇÇ c‚ÇÉ :=
begin
  haveI : (basic_universal_map.comp f g).suitable c‚ÇÉ c‚ÇÅ := suitable_comp c‚ÇÇ,
  simp only [eval_LCFP'_def, eval_FP_comp r' _ c‚ÇÇ, nat_trans.op_comp, whisker_right_comp]
end

lemma eval_LCFP_comp (f : basic_universal_map m n) (g : basic_universal_map l m)
  [hf : f.suitable c‚ÇÇ c‚ÇÅ] [hg : g.suitable c‚ÇÉ c‚ÇÇ] :
  @eval_LCFP V r' _ _ (basic_universal_map.comp f g) c‚ÇÅ c‚ÇÉ (suitable_comp c‚ÇÇ) =
    f.eval_LCFP V r' c‚ÇÅ c‚ÇÇ ‚â´ g.eval_LCFP V r' c‚ÇÇ c‚ÇÉ :=
by { simp only [eval_LCFP_eq_eval_LCFP'], apply eval_LCFP'_comp }

lemma res_comp_eval_LCFP
  [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] [fact (c‚ÇÑ ‚â§ c‚ÇÉ)] [œï.suitable c‚ÇÑ c‚ÇÇ] [œï.suitable c‚ÇÉ c‚ÇÅ] :
  res V r' c‚ÇÅ c‚ÇÇ n ‚â´ œï.eval_LCFP V r' c‚ÇÇ c‚ÇÑ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÉ ‚â´ res V r' c‚ÇÉ c‚ÇÑ m :=
by simp only [res, eval_LCFP, ‚Üê whisker_right_comp, ‚Üê nat_trans.op_comp,
  cast_le_comp_eval_FP _ c‚ÇÑ c‚ÇÉ c‚ÇÇ c‚ÇÅ]

lemma Tinv_comp_eval_LCFP [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] [fact (c‚ÇÑ ‚â§ r' * c‚ÇÉ)]
  [œï.suitable c‚ÇÑ c‚ÇÇ] [œï.suitable c‚ÇÉ c‚ÇÅ] :
  Tinv V r' c‚ÇÅ c‚ÇÇ n ‚â´ œï.eval_LCFP V r' c‚ÇÇ c‚ÇÑ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÉ ‚â´ Tinv V r' c‚ÇÉ c‚ÇÑ m :=
by simp only [Tinv, eval_LCFP, ‚Üê whisker_right_comp, ‚Üê nat_trans.op_comp,
  Tinv_comp_eval_FP _ _ c‚ÇÑ c‚ÇÉ c‚ÇÇ c‚ÇÅ]

lemma T_inv_comp_eval_LCFP [normed_with_aut r V] [œï.suitable c‚ÇÇ c‚ÇÅ] :
  T_inv r V r' c‚ÇÅ n ‚â´ œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ ‚â´ T_inv r V r' c‚ÇÇ m :=
begin
  ext M : 2,
  simp only [T_inv_def, eval_LCFP, nat_trans.comp_app,  whisker_right_app, whisker_left_app,
    nat_trans.naturality]
end

end basic_universal_map

namespace universal_map

open free_abelian_group

variables (œï : universal_map m n)

def eval_LCFP [œï.suitable c‚ÇÇ c‚ÇÅ] : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ m :=
‚àë g : {g : basic_universal_map m n // g ‚àà œï.support},
  begin
    haveI := suitable_of_mem_support œï c‚ÇÇ c‚ÇÅ g g.2,
    exact coeff (g : basic_universal_map m n) œï ‚Ä¢ (basic_universal_map.eval_LCFP V r' g c‚ÇÅ c‚ÇÇ)
  end

def eval_LCFP' : LCFP V r' c‚ÇÅ n ‚ü∂ LCFP V r' c‚ÇÇ m :=
‚àë g in œï.support, coeff g œï ‚Ä¢ (g.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ)

lemma eval_LCFP_eq_eval_LCFP' (h : œï.suitable c‚ÇÇ c‚ÇÅ) :
  œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ = œï.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
begin
  simp only [eval_LCFP, eval_LCFP', basic_universal_map.eval_LCFP_eq_eval_LCFP',
    subtype.val_eq_coe],
  symmetry,
  apply finset.sum_subtype œï.support (Œª _, iff.rfl),
end

@[simp] lemma eval_LCFP'_of (f : basic_universal_map m n) :
  eval_LCFP' V r' c‚ÇÅ c‚ÇÇ (of f) = f.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
by simp only [eval_LCFP', support_of, coeff_of_self, one_smul, finset.sum_singleton]

@[simp] lemma eval_LCFP_of (f : basic_universal_map m n) [f.suitable c‚ÇÇ c‚ÇÅ] :
  eval_LCFP V r' c‚ÇÅ c‚ÇÇ (of f) = f.eval_LCFP V r' c‚ÇÅ c‚ÇÇ :=
by rw [eval_LCFP_eq_eval_LCFP', eval_LCFP'_of, basic_universal_map.eval_LCFP_eq_eval_LCFP']

@[simp] lemma eval_LCFP'_zero :
  (0 : universal_map m n).eval_LCFP' V r' c‚ÇÅ c‚ÇÇ = 0 :=
by rw [eval_LCFP', support_zero, finset.sum_empty]

@[simp] lemma eval_LCFP_zero :
  (0 : universal_map m n).eval_LCFP V r' c‚ÇÅ c‚ÇÇ = 0 :=
by rw [eval_LCFP_eq_eval_LCFP', eval_LCFP'_zero]

@[simp] lemma eval_LCFP'_neg (f : universal_map m n) :
  eval_LCFP' V r' c‚ÇÅ c‚ÇÇ (-f) = -f.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
by simp only [eval_LCFP', add_monoid_hom.map_neg, finset.sum_neg_distrib, neg_smul, support_neg]

@[simp] lemma eval_LCFP_neg (f : universal_map m n) [f.suitable c‚ÇÇ c‚ÇÅ] :
  eval_LCFP V r' c‚ÇÅ c‚ÇÇ (-f) = -f.eval_LCFP V r' c‚ÇÅ c‚ÇÇ :=
by simp only [eval_LCFP_eq_eval_LCFP', eval_LCFP'_neg]

lemma eval_LCFP'_add (f g : universal_map m n) :
  eval_LCFP' V r' c‚ÇÅ c‚ÇÇ (f + g) = f.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ + g.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ :=
begin
  simp only [eval_LCFP'],
  rw finset.sum_subset (support_add f g), -- two goals
  simp only [add_monoid_hom.map_add _ f g, add_smul],
  convert finset.sum_add_distrib using 2, -- three goals
  apply finset.sum_subset (finset.subset_union_left _ _), swap,
  apply finset.sum_subset (finset.subset_union_right _ _),
  all_goals { rintros x - h, rw not_mem_support_iff at h, simp [h] },
end

lemma eval_LCFP_add (f g : universal_map m n) [f.suitable c‚ÇÇ c‚ÇÅ] [g.suitable c‚ÇÇ c‚ÇÅ] :
  eval_LCFP V r' c‚ÇÅ c‚ÇÇ (f + g) = f.eval_LCFP V r' c‚ÇÅ c‚ÇÇ + g.eval_LCFP V r' c‚ÇÅ c‚ÇÇ :=
by simp only [eval_LCFP_eq_eval_LCFP', eval_LCFP'_add]

lemma eval_LCFP_sub (f g : universal_map m n) [f.suitable c‚ÇÇ c‚ÇÅ] [g.suitable c‚ÇÇ c‚ÇÅ] :
  eval_LCFP V r' c‚ÇÅ c‚ÇÇ (f - g) = f.eval_LCFP V r' c‚ÇÅ c‚ÇÇ - g.eval_LCFP V r' c‚ÇÅ c‚ÇÇ :=
by simp only [sub_eq_add_neg, eval_LCFP_add, eval_LCFP_neg]

lemma eval_LCFP'_comp_of (g : basic_universal_map m n) (f : basic_universal_map l m)
  [hg : g.suitable c‚ÇÇ c‚ÇÅ] [hf : f.suitable c‚ÇÉ c‚ÇÇ] :
  eval_LCFP' V r' c‚ÇÅ c‚ÇÉ ((comp (of g)) (of f)) =
    eval_LCFP' V r' c‚ÇÅ c‚ÇÇ (of g) ‚â´ eval_LCFP' V r' c‚ÇÇ c‚ÇÉ (of f) :=
begin
  simp only [comp_of, eval_LCFP'_of],
  haveI hfg : (basic_universal_map.comp g f).suitable c‚ÇÉ c‚ÇÅ := basic_universal_map.suitable_comp c‚ÇÇ,
  rw ‚Üê basic_universal_map.eval_LCFP'_comp,
end

open category_theory category_theory.limits category_theory.preadditive

lemma eval_LCFP'_comp (g : universal_map m n) (f : universal_map l m)
  [hg : g.suitable c‚ÇÇ c‚ÇÅ] [hf : f.suitable c‚ÇÉ c‚ÇÇ] :
  (comp g f).eval_LCFP' V r' c‚ÇÅ c‚ÇÉ = g.eval_LCFP' V r' c‚ÇÅ c‚ÇÇ ‚â´ f.eval_LCFP' V r' c‚ÇÇ c‚ÇÉ :=
begin
  unfreezingI { revert hf },
  apply free_abelian_group.induction_on_free_predicate
    (suitable c‚ÇÇ c‚ÇÅ) (suitable_free_predicate c‚ÇÇ c‚ÇÅ) g hg; unfreezingI { clear_dependent g },
  { intros h‚ÇÇ,
    simp only [eval_LCFP'_zero, zero_comp, pi.zero_apply,
      add_monoid_hom.zero_apply, add_monoid_hom.map_zero] },
  { intros g hg hf,
    -- now do another nested induction on `f`
    apply free_abelian_group.induction_on_free_predicate
      (suitable c‚ÇÉ c‚ÇÇ) (suitable_free_predicate c‚ÇÉ c‚ÇÇ) f hf; unfreezingI { clear_dependent f },
    { simp only [eval_LCFP'_zero, comp_zero, add_monoid_hom.map_zero] },
    { intros f hf,
      rw suitable_of_iff at hf hg,
      resetI,
      apply eval_LCFP'_comp_of },
    { intros f hf IH,
      simp only [IH, eval_LCFP'_neg, add_monoid_hom.map_neg, comp_neg] },
    { rintros (f‚ÇÅ : universal_map l m) (f‚ÇÇ : universal_map l m) hf‚ÇÅ hf‚ÇÇ IH‚ÇÅ IH‚ÇÇ, resetI,
      haveI Hg‚ÇÅf : (comp (of g) f‚ÇÅ).suitable c‚ÇÉ c‚ÇÅ := suitable.comp c‚ÇÇ,
      haveI Hg‚ÇÇf : (comp (of g) f‚ÇÇ).suitable c‚ÇÉ c‚ÇÅ := suitable.comp c‚ÇÇ,
      simp only [add_monoid_hom.map_add, eval_LCFP'_add, IH‚ÇÅ, IH‚ÇÇ, comp_add] } },
  { intros g hg IH hf, resetI, specialize IH,
    simp only [IH, add_monoid_hom.map_neg, eval_LCFP'_neg,
      add_monoid_hom.neg_apply, neg_inj, neg_comp] },
  { rintros (g‚ÇÅ : universal_map m n) (g‚ÇÇ : universal_map m n) hg‚ÇÅ hg‚ÇÇ IH‚ÇÅ IH‚ÇÇ hf, resetI,
    haveI Hg‚ÇÅf : (comp g‚ÇÅ f).suitable c‚ÇÉ c‚ÇÅ := suitable.comp c‚ÇÇ,
    haveI Hg‚ÇÇf : (comp g‚ÇÇ f).suitable c‚ÇÉ c‚ÇÅ := suitable.comp c‚ÇÇ,
    simp only [add_monoid_hom.map_add, add_monoid_hom.add_apply, eval_LCFP'_add, IH‚ÇÅ, IH‚ÇÇ, add_comp] }
end

lemma eval_LCFP_comp (g : universal_map m n) (f : universal_map l m)
  [hg : g.suitable c‚ÇÇ c‚ÇÅ] [hf : f.suitable c‚ÇÉ c‚ÇÇ] :
  @eval_LCFP V r' c‚ÇÅ c‚ÇÉ _ _ (comp g f) (suitable.comp c‚ÇÇ) =
    g.eval_LCFP V r' c‚ÇÅ c‚ÇÇ ‚â´ f.eval_LCFP V r' c‚ÇÇ c‚ÇÉ :=
by { simp only [eval_LCFP_eq_eval_LCFP'], apply eval_LCFP'_comp }

lemma res_comp_eval_LCFP [fact (c‚ÇÇ ‚â§ c‚ÇÅ)] [fact (c‚ÇÑ ‚â§ c‚ÇÉ)] [œï.suitable c‚ÇÉ c‚ÇÅ] [œï.suitable c‚ÇÑ c‚ÇÇ] :
  res V r' c‚ÇÅ c‚ÇÇ n ‚â´ œï.eval_LCFP V r' c‚ÇÇ c‚ÇÑ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÉ ‚â´ res V r' c‚ÇÉ c‚ÇÑ m :=
begin
  simp only [eval_LCFP, comp_sum, sum_comp],
  apply finset.sum_congr rfl,
  rintros ‚ü®g, hg‚ü© -,
  -- instead of this crazy `show`, we shoul prove `comp_gsmul` and `gsmul_comp`
  -- for preadditive categories
  show @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ SemiNormedGroup) _ _ _ _ _ _ _ =
    @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ SemiNormedGroup) _ _ _ _ _ _ _,
  simp only [add_monoid_hom.map_gsmul, add_monoid_hom.smul_apply],
  haveI : g.suitable c‚ÇÉ c‚ÇÅ := suitable_of_mem_support œï _ _ g hg,
  haveI : g.suitable c‚ÇÑ c‚ÇÇ := suitable_of_mem_support œï _ _ g hg,
  congr' 1,
  apply g.res_comp_eval_LCFP V r' c‚ÇÅ c‚ÇÇ c‚ÇÉ c‚ÇÑ
end

lemma Tinv_comp_eval_LCFP [fact (c‚ÇÇ ‚â§ r' * c‚ÇÅ)] [fact (c‚ÇÑ ‚â§ r' * c‚ÇÉ)]
  [œï.suitable c‚ÇÉ c‚ÇÅ] [œï.suitable c‚ÇÑ c‚ÇÇ] :
  Tinv V r' c‚ÇÅ c‚ÇÇ n ‚â´ œï.eval_LCFP V r' c‚ÇÇ c‚ÇÑ = œï.eval_LCFP V r' c‚ÇÅ c‚ÇÉ ‚â´ Tinv V r' c‚ÇÉ c‚ÇÑ m :=
begin
  simp only [eval_LCFP, comp_sum, sum_comp],
  apply finset.sum_congr rfl,
  rintros ‚ü®g, hg‚ü© -,
  show @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ SemiNormedGroup) _ _ _ _ _ _ _ =
    @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ SemiNormedGroup) _ _ _ _ _ _ _,
  simp only [add_monoid_hom.map_gsmul, add_monoid_hom.smul_apply],
  haveI : g.suitable c‚ÇÉ c‚ÇÅ := suitable_of_mem_support œï _ _ g hg,
  haveI : g.suitable c‚ÇÑ c‚ÇÇ := suitable_of_mem_support œï _ _ g hg,
  congr' 1,
  apply basic_universal_map.Tinv_comp_eval_LCFP V r'
end

lemma T_inv_comp_eval_LCFP [normed_with_aut r V] [œï.suitable c‚ÇÇ c‚ÇÅ] :
  T_inv r V r' c‚ÇÅ n ‚â´ œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ =
    œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ ‚â´ T_inv r V r' c‚ÇÇ m :=
begin
  simp only [eval_LCFP, comp_sum, sum_comp],
  apply finset.sum_congr rfl,
  rintros ‚ü®g, hg‚ü© -,
  show @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ SemiNormedGroup) _ _ _ _ _ _ _ =
    @comp_hom ((ProFiltPseuNormGrpWithTinv r')·µí·µñ ‚•§ SemiNormedGroup) _ _ _ _ _ _ _,
  simp only [add_monoid_hom.map_gsmul, add_monoid_hom.smul_apply],
  haveI : g.suitable c‚ÇÇ c‚ÇÅ := suitable_of_mem_support œï _ _ g hg,
  congr' 1,
  apply basic_universal_map.T_inv_comp_eval_LCFP r V r'
end

lemma norm_eval_LCFP_le [œï.suitable c‚ÇÇ c‚ÇÅ]
  (N : ‚Ñï) (h : œï.bound_by N) (M) :
  ‚à•(œï.eval_LCFP V r' c‚ÇÅ c‚ÇÇ).app M‚à• ‚â§ N :=
begin
  rw [eval_LCFP_eq_eval_LCFP', eval_LCFP'],
  have : (‚àë (g : basic_universal_map m n) in support œï, (coeff g œï).nat_abs : ‚Ñù) ‚â§ N,
  { exact_mod_cast h },
  simp only [‚Üê nat_trans.app_hom_apply, add_monoid_hom.map_sum, add_monoid_hom.map_int_module_smul],
  refine le_trans (norm_sum_le_of_le œï.support _) this,
  intros g hg,
  have aux := œï.suitable_of_mem_support c‚ÇÇ c‚ÇÅ g hg,
  refine le_trans (norm_gsmul_le _ _) _,
  suffices : ‚à•(nat_trans.app_hom M) (basic_universal_map.eval_LCFP' V r' g c‚ÇÅ c‚ÇÇ)‚à• ‚â§ 1,
  { have aux‚ÇÅ : ‚à•(coeff g) œï‚à• = ‚Üë(((coeff g) œï).nat_abs),
    { rw [@coe_coe ‚Ñï ‚Ñ§ ‚Ñù _ _ _, ‚Üê int.abs_eq_nat_abs, int.cast_abs],
    refl },
    rw aux‚ÇÅ,
    exact mul_le_of_le_one_right ((coeff g) œï).nat_abs.cast_nonneg this },
  rw [‚Üê g.eval_LCFP_eq_eval_LCFP' V r' c‚ÇÅ c‚ÇÇ, basic_universal_map.eval_LCFP],
  { apply normed_group_hom.norm_noninc.norm_noninc_iff_norm_le_one.1,
    exact locally_constant.comap_hom_norm_noninc _ _, exact aux },
end

end universal_map

end breen_deligne
