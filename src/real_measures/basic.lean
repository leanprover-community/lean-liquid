import analysis.special_functions.pow
import analysis.specific_limits.basic
import analysis.normed_space.basic
import analysis.mean_inequalities_pow
import category_theory.Fintype

import pseudo_normed_group.basic
import pseudo_normed_group.category

import for_mathlib.nnreal
import for_mathlib.real

/-

# Real measures

If `p : ‚Ñù‚â•0` and `S : Fintype` then `real_measures p S` is just the functions
from `S` to `‚Ñù`, equipped with its `‚Ñì·µñ` norm.
-/
universe u

noncomputable theory
open_locale big_operators nnreal classical

/-- `real_measures p S` is the vector space of maps `S ‚Üí ‚Ñù` equipped with the `‚Ñì·µñ` norm,
which gives it the structure of a `CompHausl`y-filtered normed group.  -/
@[nolint unused_arguments, derive add_comm_group]
def real_measures (p : ‚Ñù‚â•0) (S : Fintype) := S ‚Üí ‚Ñù

variables {p : ‚Ñù‚â•0} {S S' : Fintype.{u}}

local notation `‚Ñ≥` := real_measures
local notation `œñ` := Fintype.of punit

namespace real_measures

@[simp] lemma zero_apply (s : S) : (0 : ‚Ñ≥ p S) s = 0 := rfl

@[simp] lemma add_apply (F G : ‚Ñ≥ p S) (s : S) : (F + G) s = F s + G s := rfl

@[simp] lemma neg_apply (F : ‚Ñ≥ p S) (s : S) : (-F) s = - (F s) := rfl

@[simp] lemma sub_apply (F G : ‚Ñ≥ p S) (s : S) : (F - G) s = F s - G s := rfl

instance : has_norm (‚Ñ≥ p S) := ‚ü®Œª F, ‚àë s, ‚à•F s‚à• ^ (p:‚Ñù)‚ü©

lemma norm_def (F : ‚Ñ≥ p S) : ‚à•F‚à• = ‚àë s, ‚à•F s‚à• ^ (p:‚Ñù) := rfl

instance : has_nnnorm (‚Ñ≥ p S) := ‚ü®Œª F, ‚àë s, ‚à•F s‚à•‚Çä ^ (p:‚Ñù)‚ü©

lemma nnnorm_def (F : ‚Ñ≥ p S) : ‚à•F‚à•‚Çä = ‚àë s, ‚à•F s‚à•‚Çä ^ (p:‚Ñù) := rfl

@[simp] protected lemma coe_nnnorm (F : ‚Ñ≥ p S) : (‚à•F‚à•‚Çä : ‚Ñù) = ‚à•F‚à• :=
by simp only [norm_def, nnnorm_def, nnreal.coe_sum, nnreal.coe_rpow, coe_nnnorm]

lemma real_measures.norm_nonneg (F : ‚Ñ≥ p S) : 0 ‚â§ ‚à• F ‚à• := by {rw [‚Üê F.coe_nnnorm], from ‚à• F ‚à•‚Çä.2}

@[simp] protected lemma nnnorm_zero [hp : fact (0 < p)] : ‚à•(0 : ‚Ñ≥ p S)‚à•‚Çä = 0 :=
begin
  rw [nnnorm_def, finset.sum_eq_zero],
  rintro s -,
  rw [zero_apply, nnnorm_zero, nnreal.zero_rpow],
  exact_mod_cast hp.out.ne',
end

protected lemma nnnorm_add [h0p : fact (0 ‚â§ p)] [hp1 : fact (p ‚â§ 1)]
  (F G : ‚Ñ≥ p S) : ‚à•F + G‚à•‚Çä ‚â§ ‚à•F‚à•‚Çä + ‚à•G‚à•‚Çä :=
begin
  dsimp [nnnorm_def],
  rw ‚Üê finset.sum_add_distrib,
  apply finset.sum_le_sum,
  intros s hs,
  have h0p' : (0 : ‚Ñù) ‚â§ p, exact_mod_cast h0p.out,
  have hp1' : (p : ‚Ñù) ‚â§ 1, exact_mod_cast hp1.out,
  exact (nnreal.rpow_le_rpow (nnnorm_add_le _ _) h0p').trans
    (@nnreal.rpow_add_le_add_rpow p (‚à•F s‚à•‚Çä) (‚à•G s‚à•‚Çä) h0p' hp1'),
end

--needed? [FAE] Yes!
instance png_real_measures [fact (0 < p)] [fact (p ‚â§ 1)] : pseudo_normed_group (‚Ñ≥ p S) :=
{ filtration := Œª c, { F | ‚à•F‚à•‚Çä ‚â§ c },
  filtration_mono := Œª c‚ÇÅ c‚ÇÇ h F hF, by {dsimp at *, exact le_trans hF h},
  zero_mem_filtration := Œª c, by simp only [real_measures.nnnorm_zero, zero_le', set.mem_set_of_eq],
  neg_mem_filtration := Œª c F h, by { dsimp [nnnorm_def] at *, simp only [h, nnnorm_neg] },
  add_mem_filtration := Œª c‚ÇÅ c‚ÇÇ F‚ÇÅ F‚ÇÇ h‚ÇÅ h‚ÇÇ,
    (real_measures.nnnorm_add _ _).trans (add_le_add h‚ÇÅ h‚ÇÇ) }

lemma mem_filtration_iff [fact (0 < p)] [fact (p ‚â§ 1)] (F : ‚Ñ≥ p S) (c : ‚Ñù‚â•0) :
  F ‚àà pseudo_normed_group.filtration (‚Ñ≥ p S) c ‚Üî ‚à•F‚à•‚Çä ‚â§ c := iff.rfl

def map (f : S ‚ü∂ S') : ‚Ñ≥ p S ‚Üí ‚Ñ≥ p S' :=
Œª F s', ‚àë s in finset.univ.filter (Œª t, f t = s'), F s

@[simp]
lemma map_apply (f : S ‚ü∂ S') (F : ‚Ñ≥ p S) (s' : S') :
  map f F s' = ‚àë s in finset.univ.filter (Œª t, f t = s'), F s := rfl

@[simp]
lemma map_id : (map (ùüô S) : ‚Ñ≥ p S ‚Üí ‚Ñ≥ p S) = id :=
begin
  ext F s,
  rw [map_apply, finset.sum_filter, id.def],
  simp only [Fintype.id_apply, finset.sum_ite_eq', finset.mem_univ, if_true],
end

@[simp]
lemma map_comp {S'' : Fintype.{u}} (f : S ‚ü∂ S') (g : S' ‚ü∂ S'') :
  (map (f ‚â´ g) : ‚Ñ≥ p S ‚Üí ‚Ñ≥ p S'') = map g ‚àò map f :=
begin
  ext F s,
  simp only [function.comp_app, map_apply],
  convert finset.sum_bUnion _ using 1, swap 2, { classical, apply_instance },
  { apply finset.sum_congr,
    { change finset.univ.filter (Œª t, g (f t) = s) = _,
      ext i,
      simp only [true_and, exists_prop, finset.mem_univ, finset.mem_bUnion,
        exists_eq_right', finset.mem_filter] },
    { intros, refl } },
  { intros i hi j hj h k hk,
    refine h _,
    simp only [true_and, finset.inf_eq_inter, finset.mem_univ,
      finset.mem_filter, finset.mem_inter] at hk,
    rw [‚Üê hk.1, ‚Üê hk.2] }
end

lemma map_bound [h0p : fact (0 < p)] [hp1 : fact (p ‚â§ 1)] (f : S ‚ü∂ S') (F : ‚Ñ≥ p S) :
  ‚à•map f F‚à•‚Çä ‚â§ ‚à•F‚à•‚Çä :=
begin
  calc ‚àë s', ‚à•‚àë s in finset.univ.filter (Œª t, f t = s'), F s‚à•‚Çä ^ (p:‚Ñù)
      ‚â§ ‚àë s' : S', ‚àë s in finset.univ.filter (Œª t, f t = s'), ‚à•F s‚à•‚Çä ^ (p:‚Ñù) : _
  ... = ‚àë s, ‚à•F s‚à•‚Çä ^ (p:‚Ñù) : _,
  { apply finset.sum_le_sum,
    rintros s' -,
    have h0p' : (0 : ‚Ñù) < p, exact_mod_cast h0p.out,
    have hp1' : (p : ‚Ñù) ‚â§ 1, exact_mod_cast hp1.out,
    exact (nnreal.rpow_le_rpow (nnnorm_sum_le _ _) h0p'.le).trans
      (nnreal.rpow_sum_le_sum_rpow _ _ h0p' hp1'), },
  { rw ‚Üê finset.sum_bUnion,
    { refine finset.sum_congr _ _,
      { ext s,
        simp only [true_and, finset.mem_univ, finset.mem_bUnion, iff_true,
          exists_true_left, finset.mem_filter],
        refine ‚ü®_, rfl‚ü©, },
      { intros, refl } },
    { rintro x - y - h i hi,
      apply h,
      simp only [true_and, finset.inf_eq_inter, finset.mem_univ,
        finset.mem_filter, finset.mem_inter] at hi,
      rw [‚Üê hi.1, ‚Üê hi.2] } },
end

def seval_‚Ñ≥ {r : ‚Ñù‚â•0} (S : Fintype) (s : S): (real_measures r S) ‚Üí
  (real_measures r (Fintype.of punit)) := Œª F, (Œª _, F s)

variables [fact (0 < p)] [fact (p ‚â§ 1)]

open pseudo_normed_group (filtration)

instance topological_space (c : ‚Ñù‚â•0) : topological_space (filtration (‚Ñ≥ p S) c) :=
@subtype.topological_space _ _ Pi.topological_space

instance t2_space (c : ‚Ñù‚â•0) : t2_space (filtration (‚Ñ≥ p S) c) :=
@subtype.t2_space _ _ Pi.topological_space _

lemma nnnorm_apply_le_of_nnnorm_le (F : ‚Ñ≥ p S) (s : S) (c : ‚Ñù‚â•0) (h : ‚à•F‚à•‚Çä ‚â§ c) :
  ‚à•F s‚à•‚Çä ‚â§ c ^ (p‚Åª¬π : ‚Ñù) :=
begin
  calc ‚à•F s‚à•‚Çä = (‚à•F s‚à•‚Çä ^ (p:‚Ñù)) ^ (p‚Åª¬π : ‚Ñù) : _
  ... ‚â§ c ^ (p‚Åª¬π : ‚Ñù) : _,
  { rw_mod_cast [‚Üê nnreal.rpow_mul, mul_inv_cancel, nnreal.rpow_one],
    exact ne_of_gt (‚Äπfact (0 < p)‚Ä∫.out) },
  { apply nnreal.rpow_le_rpow _ (inv_pos.mpr _).le,
    { refine le_trans _ h,
      have aux := finset.sum_pi_single' s (‚à•F s‚à•‚Çä ^ (p:‚Ñù)) finset.univ,
      simp only [finset.mem_univ, if_true] at aux,
      rw ‚Üê aux,
      apply finset.sum_le_sum,
      rintro t -,
      split_ifs, { subst t }, { exact zero_le' } },
    { norm_cast, exact ‚Äπfact (0 < p)‚Ä∫.out } }
end

lemma apply_mem_Icc_of_nnnorm_le (F : ‚Ñ≥ p S) (s : S) (c : ‚Ñù‚â•0) (h : ‚à•F‚à•‚Çä ‚â§ c) :
  F s ‚àà set.Icc (-c ^ (p‚Åª¬π : ‚Ñù) : ‚Ñù) (c ^ (p‚Åª¬π : ‚Ñù) : ‚Ñù) :=
begin
  have := @set.mem_Icc_iff_abs_le ‚Ñù _ 0 (F s) (c ^ (p:‚Ñù)‚Åª¬π),
  simp only [zero_sub, abs_neg, zero_add, ‚Üê real.norm_eq_abs, ‚Üê coe_nnnorm, nnnorm_neg] at this,
  rw ‚Üê this,
  norm_cast,
  exact nnnorm_apply_le_of_nnnorm_le F s c h
end

-- move me
lemma continuous.sum {Œπ X A : Type*} [topological_space X]
  [topological_space A] [add_comm_monoid A] [has_continuous_add A]
  (s : finset Œπ) (f : Œπ ‚Üí X ‚Üí A) (hf : ‚àÄ i ‚àà s, continuous (f i)) :
  continuous (‚àë i in s, f i) :=
begin
  induction s using finset.induction_on with i s his IH,
  { simp only [finset.sum_empty], exact @continuous_zero X A _ _ _ },
  { simp only [his, finset.sum_insert, not_false_iff],
    refine (hf i $ s.mem_insert_self i).add (IH $ Œª i hi, hf i $ finset.mem_insert_of_mem hi), }
end

-- move me
lemma continuous.sum' {Œπ X A : Type*} [topological_space X]
  [topological_space A] [add_comm_monoid A] [has_continuous_add A]
  (s : finset Œπ) (f : Œπ ‚Üí X ‚Üí A) (hf : ‚àÄ i ‚àà s, continuous (f i)) :
  continuous (Œª x, ‚àë i in s, f i x) :=
begin
  induction s using finset.induction_on with i s his IH,
  { simp only [finset.sum_empty], exact @continuous_zero X A _ _ _ },
  { simp only [his, finset.sum_insert, not_false_iff],
    refine (hf i $ s.mem_insert_self i).add (IH $ Œª i hi, hf i $ finset.mem_insert_of_mem hi), }
end

instance compact_space (c : ‚Ñù‚â•0) : compact_space (filtration (‚Ñ≥ p S) c) :=
begin
  constructor,
  rw [‚Üê embedding_subtype_coe.to_inducing.is_compact_iff],
  simp only [set.image_univ, subtype.range_coe_subtype, set.set_of_mem_eq],
  let d : ‚Ñù := c ^ (p‚Åª¬π : ‚Ñù),
  let T : set (S ‚Üí ‚Ñù) := {x | ‚àÄ s, x s ‚àà set.Icc (-d) d},
  have hT : is_compact T := is_compact_pi_infinite (Œª s, is_compact_Icc),
  refine compact_of_is_closed_subset hT _ (Œª F hF s, apply_mem_Icc_of_nnnorm_le F s c hF),
  refine is_closed_le (continuous.sum' _ _ _) continuous_const,
  rintro s -,
  have h0p : 0 ‚â§ (p : ‚Ñù), { norm_cast, exact fact.out _ },
  exact (nnreal.continuous_rpow_const h0p).comp (continuous_nnnorm.comp (continuous_apply s)),
end

open metric

def equiv_filtration_œñ_ball (c : ‚Ñù‚â•0) : filtration (‚Ñ≥ p œñ) c ‚âÉ closed_ball (0 : ‚Ñù)
  (c ^ (p‚Åª¬π : ‚Ñù) : ‚Ñù‚â•0):=
{ to_fun := Œª f, ‚ü®f.1 punit.star, begin
    simp only [mem_closed_ball_zero_iff],
    have hf := (mem_filtration_iff f.1 c).mp f.2,
    simp only [‚Üê nnreal.coe_le_coe, real_measures.coe_nnnorm, nnnorm_def, fintype.univ_punit, finset.sum_singleton, norm_def]
      at hf,
    have := @nnreal.rpow_le_rpow_iff (‚à•f.1 punit.star‚à•‚Çä) (c ^ (p‚Åª¬π : ‚Ñù)) p _,
    rw [‚Üê nnreal.rpow_mul, inv_mul_cancel, nnreal.rpow_one] at this,
    exact this.mp hf,
    exact (nnreal.coe_ne_zero.mpr (ne_of_gt (fact.out _))),
    rw ‚Üê nnreal.coe_zero,
    exact nnreal.coe_lt_coe.mpr (fact.out _),
  end‚ü©,
  inv_fun := Œª x, ‚ü®Œª _, x, begin
    have := @real.rpow_le_rpow_iff (|‚Üëx| : ‚Ñù) (c ^ (p‚Åª¬π : ‚Ñù)) p _ _ _,
    rw [‚Üê real.rpow_mul, inv_mul_cancel, real.rpow_one] at this,
    have hx := x.2,
    simp only [mem_filtration_iff, subtype.val_eq_coe, nnnorm, fintype.univ_punit,
      finset.sum_singleton, ‚Üê nnreal.coe_le_coe, nnreal.coe_rpow, subtype.coe_mk, real.norm_eq_abs,
      this, abs_le, mem_closed_ball_zero_iff] at hx ‚ä¢,
    exact hx,
    { rw nnreal.coe_ne_zero,
      exact ne_of_gt (fact.out _) },
    { exact c.2 },
    { exact abs_nonneg x },
    { rw ‚Üê nnreal.coe_rpow,
     exact (c ^ (p‚Åª¬π : ‚Ñù)).2 },
    { rw [‚Üê nnreal.coe_zero, nnreal.coe_lt_coe],
      exact fact.out _ }
  end‚ü©,
  left_inv := begin
    intro,
      ext,
      simp only [subtype.val_eq_coe, subtype.coe_mk],
      apply congr_arg,
      simp only [eq_iff_true_of_subsingleton]
  end,
  right_inv := begin
    intro,
    simp only [subtype.coe_eta]
  end }

def homeo_filtration_œñ_ball (c : ‚Ñù‚â•0) : filtration (‚Ñ≥ p œñ) c ‚âÉ‚Çú closed_ball (0 : ‚Ñù)
  (c ^ (p‚Åª¬π : ‚Ñù) : ‚Ñù‚â•0) :=
{ to_equiv := equiv_filtration_œñ_ball c,
  continuous_to_fun := begin
    refine continuous.subtype_mk (Œª (x : {F // ‚à•F‚à•‚Çä ‚â§ c}), equiv_filtration_œñ_ball._proof_1 c x) _,
    exact continuous.comp (continuous_apply punit.star) continuous_subtype_coe,
  end,
  continuous_inv_fun := begin
    simp only [equiv_filtration_œñ_ball],
    continuity,
  end
}

lemma real_measures.dist_eq {c : ‚Ñù‚â•0} (F G : filtration (‚Ñ≥ p œñ) c) : ‚à• F.1 - G.1 ‚à• ^ (p‚Åª¬π : ‚Ñù) =
  | ((homeo_filtration_œñ_ball c F) - (homeo_filtration_œñ_ball c G) : ‚Ñù)| :=
begin
  have hp : (p : ‚Ñù) ‚â† 0,
  { rw ‚Üê nnreal.coe_zero,
    exact (ne_of_gt (nnreal.coe_lt_coe.mpr (fact.out _))) },
  simp only [norm_def, fintype.univ_punit, subtype.val_eq_coe, sub_apply, finset.sum_singleton,
    ‚Üê real.rpow_mul (norm_nonneg _), mul_inv_cancel hp],
  simpa only [real.rpow_one, real.norm_eq_abs],
end

instance {c : ‚Ñù‚â•0} : has_zero (closed_ball (0 : ‚Ñù) c):=
  { zero := ‚ü®0, by {simp only [mem_closed_ball_zero_iff, norm_zero, nnreal.zero_le_coe]}‚ü©}

lemma homeo_filtration_œñ_ball_preimage {c Œµ: ‚Ñù‚â•0} (h : Œµ ^ (p : ‚Ñù) ‚â§ c) :
  (homeo_filtration_œñ_ball c)‚Åª¬π' (closed_ball 0 Œµ) =
  (set.range (set.inclusion (@pseudo_normed_group.filtration_mono (‚Ñ≥ p œñ) _ _ _ h))) :=
begin
  ext ‚ü®x, hx‚ü©,
  simp only [homeo_filtration_œñ_ball, equiv_filtration_œñ_ball, subtype.val_eq_coe, subtype.coe_mk,
    homeomorph.homeomorph_mk_coe, equiv.coe_fn_mk, set.mem_preimage, mem_closed_ball, dist_le_coe,
    set.range_inclusion, set.mem_set_of_eq],
  change _ ‚Üî ‚àë s : punit, ‚à•x s‚à•‚Çä ^ (p:‚Ñù) ‚â§ _,
  simp only [fintype.univ_punit, finset.sum_singleton],
  rw nnreal.rpow_le_rpow_iff,
  { convert iff.rfl,
    convert (sub_zero _).symm },
  { norm_cast, exact fact.elim infer_instance },
end

-- **[FAE]** The following ones with `_Icc_` might be useless

-- def equiv_filtration_œñ_Icc (c : ‚Ñù‚â•0) : filtration (‚Ñ≥ p œñ) c ‚âÉ set.Icc ((- c ^ (p‚Åª¬π : ‚Ñù)) : ‚Ñù)
--   (c ^ (p‚Åª¬π : ‚Ñù)):=
-- begin
--   fconstructor,
--   { intro f,
--     exact ‚ü®f.1 punit.star, apply_mem_Icc_of_nnnorm_le _ _ _ f.2‚ü© },
--   { intro x,
--     use (Œª _, x),
--     have := @real.rpow_le_rpow_iff (|‚Üëx| : ‚Ñù) (c ^ (p‚Åª¬π : ‚Ñù)) p _ _ _,
--     rw [‚Üê real.rpow_mul, inv_mul_cancel, real.rpow_one] at this,
--     have hx := x.2,
--     simpa only [mem_filtration_iff, subtype.val_eq_coe, set.mem_Icc, nnnorm, fintype.univ_punit,
--       finset.sum_singleton, ‚Üê nnreal.coe_le_coe, nnreal.coe_rpow, subtype.coe_mk, real.norm_eq_abs,
--       this, abs_le],
--     { rw nnreal.coe_ne_zero,
--       exact ne_of_gt (fact.out _) },
--     { exact c.2 },
--     { exact abs_nonneg x },
--     { rw ‚Üê nnreal.coe_rpow,
--      exact (c ^ (p‚Åª¬π : ‚Ñù)).2 },
--     { rw [‚Üê nnreal.coe_zero, nnreal.coe_lt_coe],
--       exact fact.out _ } },
--     { intro f,
--       ext s,
--       simp only [subtype.val_eq_coe, subtype.coe_mk],
--       apply congr_arg,
--       simp only [eq_iff_true_of_subsingleton] },
--     { intro x,
--       simp only [subtype.coe_eta] },
-- end

-- def homeo_filtration_œñ_Icc (c : ‚Ñù‚â•0) : filtration (‚Ñ≥ p œñ) c ‚âÉ‚Çú set.Icc ((- c ^ (p‚Åª¬π : ‚Ñù)) : ‚Ñù)
--   (c ^ (p‚Åª¬π : ‚Ñù)) :=
-- { to_equiv := equiv_filtration_œñ_Icc c,
--   continuous_to_fun := admit,
--   continuous_inv_fun := admit
-- }


-- lemma homeo_filtration_œñ_Icc_apply (c c': ‚Ñù‚â•0) (h : c ‚â§ c') :
-- (homeo_filtration_œñ_Icc c').to_fun '' (set.range (set.inclusion (@pseudo_normed_group.filtration_mono (‚Ñ≥ p œñ) _ _ _ h)))
--   = ‚ä• := --set.Icc ((- c ^ (p‚Åª¬π : ‚Ñù)) : ‚Ñù) ((c ^ (p‚Åª¬π : ‚Ñù) : ‚Ñù)) :=
-- begin
--   admit,
-- end

instance chpng_real_measures : comphaus_filtered_pseudo_normed_group (‚Ñ≥ p S) :=
{ continuous_add' := begin
    intros c‚ÇÅ c‚ÇÇ,
    rw continuous_induced_rng,
    simp only [function.comp, pseudo_normed_group.add'_eq],
    exact (continuous_subtype_val.comp continuous_fst).add
          (continuous_subtype_val.comp continuous_snd),
  end,
  continuous_neg' := begin
    intros c,
    rw continuous_induced_rng,
    simp only [function.comp, pseudo_normed_group.neg'_eq],
    exact continuous_subtype_val.neg,
  end,
  continuous_cast_le := begin
    introsI c‚ÇÅ c‚ÇÇ h,
    rw continuous_induced_rng,
    simp only [function.comp, pseudo_normed_group.coe_cast_le],
    exact continuous_subtype_val,
  end,
  ..(infer_instance : (pseudo_normed_group (‚Ñ≥ p S))) }

variable {Œ± : Type*}

open pseudo_normed_group comphaus_filtered_pseudo_normed_group

@[simps]
def map_hom [fact (0 < p)] (f : S ‚ü∂ S') :
  strict_comphaus_filtered_pseudo_normed_group_hom (‚Ñ≥ p S) (‚Ñ≥ p S') :=
{ to_fun := map f,
  map_zero' := by { ext F s i, simp only [map_apply, finset.sum_const_zero, zero_apply], },
  map_add' := Œª F G, by { ext s i, simp only [finset.sum_add_distrib, add_apply, map_apply], },
  strict' := Œª c F hF, (map_bound _ _).trans hF,
  continuous' := Œª c, begin
    rw continuous_induced_rng,
    apply continuous_pi _,
    intro s',
    simp only [function.comp, map_apply],
    refine continuous.sum' _ _ _,
    rintro s -,
    exact (continuous_apply s).comp continuous_subtype_val,
  end }

@[simps]
def functor (p : ‚Ñù‚â•0) [fact (0 < p)] [fact (p ‚â§ 1)] : Fintype.{u} ‚•§ CompHausFiltPseuNormGrp‚ÇÅ.{u} :=
{ obj := Œª S, ‚ü®‚Ñ≥ p S, Œª F, ‚ü®‚à•F‚à•‚Çä, (mem_filtration_iff _ _).mpr le_rfl‚ü©‚ü©,
  map := Œª S T f, map_hom f,
  map_id' := Œª S, by { ext1, rw [map_hom_to_fun, map_id], refl, },
  map_comp' := Œª S S' S'' f g, by { ext1, simp only [map_hom_to_fun, map_comp], refl } }

end real_measures
