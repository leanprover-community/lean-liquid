import algebra.homology.homotopy
import category_theory.abelian.basic
import for_mathlib.short_complex_functor_category
import for_mathlib.short_complex_homological_complex

universes v u

noncomputable theory

open category_theory category_theory.limits

variables {Œπ Œπ' Œπ‚ÇÅ Œπ‚ÇÇ : Type*}

namespace complex_shape

/-- An embedding `embedding c‚ÇÅ c‚ÇÇ` between two complex shapes `Œπ‚ÇÅ` and `Œπ‚ÇÇ` is
an injection `Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ` sending related vertices to related vertices. Recall that two
vertices are related in a complex shape iff the differential between them is allowed to
be nonzero. -/
@[nolint has_inhabited_instance]
structure embedding (c‚ÇÅ : complex_shape Œπ‚ÇÅ) (c‚ÇÇ : complex_shape Œπ‚ÇÇ) :=
(f : Œπ‚ÇÅ ‚Üí Œπ‚ÇÇ)
(r : Œπ‚ÇÇ ‚Üí option Œπ‚ÇÅ)
(eq_some : ‚àÄ i‚ÇÇ i‚ÇÅ, r i‚ÇÇ = some i‚ÇÅ ‚Üî f i‚ÇÅ = i‚ÇÇ)
(c : ‚àÄ ‚¶Éi j‚¶Ñ, c‚ÇÅ.rel i j ‚Üí c‚ÇÇ.rel (f i) (f j))

namespace embedding

/-- extra condition which shall be useful to compare homology -/
def c_iff {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) : Prop :=
‚àÄ (i j), c‚ÇÅ.rel i j ‚Üî c‚ÇÇ.rel (e.f i) (e.f j)

lemma r_f {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (i : Œπ‚ÇÅ) :
  e.r (e.f i) = some i := by rw e.eq_some

lemma r_none {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (i : Œπ‚ÇÇ)
  (hi: ¬¨‚àÉ (i‚ÇÅ : Œπ‚ÇÅ), i = e.f i‚ÇÅ) : e.r i = none :=
begin
  classical,
  by_contra hi2,
  apply hi,
  obtain ‚ü®j, hj‚ü© := option.ne_none_iff_exists'.1 hi2,
  use j,
  rw e.eq_some at hj,
  rw hj,
end

/-- The map from `‚Ñ§` to `option ‚Ñï` which is `some n` on `n : ‚Ñï : ‚Ñ§` and `none otherwise. -/
def pos_int_to_onat : ‚Ñ§ ‚Üí option ‚Ñï
| (n:‚Ñï)  := n
| -[1+n] := none

/-- The map from `‚Ñ§` to `option ‚Ñï` which is `some n` on `-(n : ‚Ñï : ‚Ñ§)` and `none otherwise. -/
def neg_int_to_onat : ‚Ñ§ ‚Üí option ‚Ñï
| 0       := (0:‚Ñï)
| (n+1:‚Ñï) := none
| -[1+n]  := (n+1:‚Ñï)

/-- The obvious embedding from the ‚Ñï-indexed "cohomological" complex `* ‚Üí * ‚Üí * ‚Üí ...`
  to the corresponding ‚Ñ§-indexed complex. -/
def nat_up_int_up : embedding (complex_shape.up ‚Ñï) (complex_shape.up ‚Ñ§) :=
{ f := coe,
  r := pos_int_to_onat,
  eq_some := begin
    rintro (i|i) i',
    { split; { rintro ‚ü®rfl‚ü©, refl }, },
    { split; { rintro ‚ü®‚ü©, } }
  end,
  c := by { rintro i j (rfl : _ = _), dsimp, refl } }

/-- The obvious embedding from the ‚Ñï-indexed "homological" complex `* ‚Üê * ‚Üê * ‚Üê ...`
  to the corresponding ‚Ñ§-indexed homological complex. -/
def nat_down_int_down : embedding (complex_shape.down ‚Ñï) (complex_shape.down ‚Ñ§) :=
{ f := coe,
  r := pos_int_to_onat,
  eq_some := begin
    rintro (i|i) i',
    { split; { rintro ‚ü®rfl‚ü©, refl }, },
    { split; { rintro ‚ü®‚ü©, } }
  end,
  c := by { rintro i j (rfl : _ = _), dsimp, refl } }

/-- Obvious embedding from the `‚Ñï`-indexed homological complex `* ‚Üê * ‚Üê * ...`
  to `‚Ñ§`-indexed cohomological complex ` ... ‚Üí * ‚Üí * ‚Üí ...` sending $n$ to $-n$
  on the corresponding map `‚Ñï ‚Üí ‚Ñ§`. -/
def nat_down_int_up : embedding (complex_shape.down ‚Ñï) (complex_shape.up ‚Ñ§) :=
{ f := -coe,
  r := neg_int_to_onat,
  eq_some := begin
    rintro ((_|i)|i) (_|i'),
    any_goals { split; { rintro ‚ü®‚ü©, } },
    any_goals { split; { rintro ‚ü®rfl‚ü©, refl }, },
  end,
  c := by { rintro i j (rfl : _ = _),
    simp only [pi.neg_apply, int.coe_nat_succ, neg_add_rev, up_rel, neg_add_cancel_comm], } }

lemma nat_down_int_up_c_iff : nat_down_int_up.c_iff :=
begin
  intros i j,
  split,
  { apply nat_down_int_up.c, },
  { intro hij,
    change j+1 = i,
    dsimp [nat_down_int_up] at hij,
    rw ‚Üê int.coe_nat_eq_coe_nat_iff,
    simp only [int.coe_nat_succ],
    linarith, },
end

/-- Obvious embedding from the `‚Ñï`-indexed cohomological complex `* ‚Üí * ‚Üí * ...`
  to `‚Ñ§`-indexed homological complex ` ... ‚Üê * ‚Üê * ‚Üê ...` sending $n$ to $-n$
  on the corresponding map `‚Ñï ‚Üí ‚Ñ§`. -/
def nat_up_int_down : embedding (complex_shape.up ‚Ñï) (complex_shape.down ‚Ñ§) :=
{ f := -coe,
  r := neg_int_to_onat,
  eq_some := begin
    rintro ((_|i)|i) (_|i'),
    any_goals { split; { rintro ‚ü®‚ü©, } },
    any_goals { split; { rintro ‚ü®rfl‚ü©, refl }, },
  end,
  c := by { rintro i j (rfl : _ = _),
    simp only [pi.neg_apply, int.coe_nat_succ, neg_add_rev, down_rel, neg_add_cancel_comm] } }

end embedding

end complex_shape

variables {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ}
variables {cŒπ : complex_shape Œπ} {cŒπ' : complex_shape Œπ'}

variables {ùíû : Type*} [category ùíû] [preadditive ùíû] [has_zero_object ùíû] -- reclaim category notation!

namespace homological_complex

open_locale zero_object

section embed_X_and_d_basics

/-

`embed`, not to be confused with `embedding` later on, is simply
the extension of constructions involving the index type `Œπ` of our complex,
to the larger type `option Œπ`, with `none` being sent to `zero`.

-/
variable (X : homological_complex ùíû cŒπ)


/-- If `ùíû` is an abelian category,  and `(X·µ¢)·µ¢` is a `ùíû`-valued homological
complex on a complex-shape with index `Œπ`, then `embed.X X oi` for `oi : option Œπ`
is the value `X·µ¢` of `h` at `some i` (an object of `ùíû`), or `0` for `none`. -/
def embed.X : option Œπ ‚Üí ùíû
| (some i) := X.X i
| none     := 0

def embed.X_iso_of_none {e : option Œπ} (he : e = none) :
  embed.X X e ‚âÖ 0 :=
by { rw he, refl }

def embed.X_is_zero_of_none {e : option Œπ} (he : e = none) :
  is_zero (embed.X X e) :=
is_zero.of_iso (category_theory.limits.is_zero_zero ùíû) (embed.X_iso_of_none X he)

def embed.X_iso_of_some {e : option Œπ} {i} (he : e = some i) :
  embed.X X e ‚âÖ X.X i :=
by { rw he, refl }

@[simp] lemma embed.X_none : embed.X X none = 0 := rfl
@[simp] lemma embed.X_some (i : Œπ) : embed.X X (some i) = X.X i := rfl

/-- The morphism `X·µ¢ ‚Üí X‚±º` with `i j : option Œπ` coming from the complex `X`.
Equal to zero if either `i` or `j` is `none`.  -/
def embed.d : Œ† i j, embed.X X i ‚ü∂ embed.X X j
| (some i) (some j) := X.d i j
| (some i) none     := 0
| none     j        := 0

def embed.d_of_none_src {e‚ÇÅ e‚ÇÇ : option Œπ} (he : e‚ÇÅ = none) :
  embed.d X e‚ÇÅ e‚ÇÇ = 0 :=
by { rw he, refl }

def embed.d_of_none_tgt {e‚ÇÅ e‚ÇÇ : option Œπ} (he : e‚ÇÇ = none) :
  embed.d X e‚ÇÅ e‚ÇÇ = 0 :=
by { rw he, cases e‚ÇÅ; refl }

def embed.d_of_some_of_some {e‚ÇÅ e‚ÇÇ : option Œπ} {i j}
  (h‚ÇÅ : e‚ÇÅ = some i) (h‚ÇÇ : e‚ÇÇ = some j) :
  embed.d X e‚ÇÅ e‚ÇÇ = (embed.X_iso_of_some X h‚ÇÅ).hom ‚â´ X.d i j ‚â´
    (embed.X_iso_of_some X h‚ÇÇ).inv :=
by { subst h‚ÇÅ, subst h‚ÇÇ, change _ = ùüô _ ‚â´ _ ‚â´ ùüô _, simpa }

@[simp] lemma embed.d_some_some (i j : Œπ) : embed.d X (some i) (some j) = X.d i j :=
rfl

lemma embed.d_ne_zero (e‚ÇÅ e‚ÇÇ : option Œπ) (h : embed.d X e‚ÇÅ e‚ÇÇ ‚â† 0) :
  ‚àÉ (i j : Œπ) (h‚ÇÅ : e‚ÇÅ = some i) (h‚ÇÇ : e‚ÇÇ = some j), X.d i j ‚â† 0 :=
begin
  rcases h‚ÇÅ : e‚ÇÅ with _ | ‚ü®i‚ü©,
  { exfalso,
    apply h,
    exact embed.d_of_none_src X h‚ÇÅ, },
  { rcases h‚ÇÇ : e‚ÇÇ with _ | ‚ü®j‚ü©,
    { exfalso,
      apply h,
      exact embed.d_of_none_tgt X h‚ÇÇ, },
    { substs h‚ÇÅ h‚ÇÇ,
      refine ‚ü®i, j, rfl, rfl, h‚ü©, }, },
end

/-- Prop-valued so probably won't break anything. To deal with zerology. -/
instance homological_complex.embed.subsingleton_to_none (c : _) : subsingleton (c ‚ü∂ embed.X X none) :=
@unique.subsingleton _ (has_zero_object.unique_from c)

instance homological_complex.embed.subsingleton_of_none (c) : subsingleton (embed.X X none ‚ü∂ c) :=
@unique.subsingleton _ (has_zero_object.unique_to c)

@[simp] lemma embed.d_to_none (i : option Œπ) : embed.d X i none = 0 :=
by cases i; refl

@[simp] lemma embed.d_of_none (i : option Œπ) : embed.d X none i = 0 :=
rfl

lemma embed.shape : ‚àÄ (i j : option Œπ)
  (h : ‚àÄ (i' j' : Œπ), i = some i' ‚Üí j = some j' ‚Üí ¬¨ cŒπ.rel i' j'),
  embed.d X i j = 0
| (some i) (some j) h := X.shape _ _ $ h i j rfl rfl
| (some i) none     h := rfl
| none     j        h := rfl

lemma embed.d_comp_d : ‚àÄ i j k, embed.d X i j ‚â´ embed.d X j k = 0
| (some i) (some j) (some k) := X.d_comp_d _ _ _
| (some i) (some j) none     := comp_zero
| (some i) none     k        := comp_zero
| none     j        k        := zero_comp

end embed_X_and_d_basics

section embedding_change_of_complex

variable (e : cŒπ.embedding cŒπ')

/-- Object-valued pushforward of `ùíû`-valued homological complexes along an embedding
  `Œπ‚ÇÅ ‚Ü™ Œπ‚ÇÇ` of complex-shapes (with all indexes not in the image going to `0`). -/
def embed.obj (X : homological_complex ùíû cŒπ) : homological_complex ùíû cŒπ' :=
{ X := Œª i, embed.X X (e.r i),
  d := Œª i j, embed.d X (e.r i) (e.r j),
  shape' := Œª i j hij, embed.shape X _ _ begin
    simp only [e.eq_some],
    rintro i' j' rfl rfl h',
    exact hij (e.c h')
  end,
  d_comp_d' := Œª i j k hij hjk, embed.d_comp_d X _ _ _ }

variables {X Y Z : homological_complex ùíû cŒπ} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z)

/-- Morphism-valued pushforward of `ùíû`-valued homological complexes along an embedding of complex-shapes
( with all morphisms not in the image being defined to be 0) -/
def embed.f : Œ† i, embed.X X i ‚ü∂ embed.X Y i
| (some i) := f.f i
| none     := 0

@[simp] lemma embed.f_none : embed.f f none = 0 := rfl
@[simp] lemma embed.f_some (i : Œπ) : embed.f f (some i) = f.f i := rfl

lemma embed.f_add {f g : X ‚ü∂ Y} : ‚àÄ i, embed.f (f + g) i = embed.f f i + embed.f g i
| (some i) := by simp
| none     := by simp

lemma embed.comm :  ‚àÄ i j, embed.f f i ‚â´ embed.d Y i j = embed.d X i j ‚â´ embed.f f j
| (some i) (some j) := f.comm _ _
| (some i) none     := show _ ‚â´ 0 = 0 ‚â´ 0, by simp only [comp_zero]
| none     j        := show 0 ‚â´ 0 = 0 ‚â´ _, by simp only [zero_comp]

/-- Pushforward of a morphism `(X·µ¢)·µ¢ ‚ü∂ (Y·µ¢)·µ¢` of homological complexes with
  the same complex-shape `Œπ`, along an embedding of complex shapes c.embedding `Œπ ‚Üí Œπ'` -/
def embed.map : embed.obj e X ‚ü∂ embed.obj e Y :=
{ f := Œª i, embed.f f _,
  comm' := Œª i j hij, embed.comm f _ _ }

lemma embed.f_id : ‚àÄ i, embed.f (ùüô X) i = ùüô (embed.X X i)
| (some i) := rfl
| none     := has_zero_object.from_zero_ext _ _

lemma embed.f_comp : ‚àÄ i, embed.f (f ‚â´ g) i = embed.f f i ‚â´ embed.f g i
| (some i) := rfl
| none     := has_zero_object.from_zero_ext _ _

lemma embed.f_of_some {e : option Œπ} {i} (he : e = some i) :
  embed.f f e =
    (embed.X_iso_of_some _ he).hom ‚â´
    f.f i ‚â´
    (embed.X_iso_of_some _ he).inv :=
by { subst he, change _ = ùüô _ ‚â´ _ ‚â´ ùüô _, simp, }

/-- Functor pushing forward, for a fixed abelian category `ùíû`, the category
of `ùíû`-valued homological complexes of shape `Œπ‚ÇÅ` along an embedding `Œπ‚ÇÅ ‚Ü™ Œπ‚ÇÇ`
(not Lean notation -- fix somehow?) of complexes. -/
def embed : homological_complex ùíû cŒπ ‚•§ homological_complex ùíû cŒπ' :=
{ obj := embed.obj e,
  map := Œª X Y f, embed.map e f,
  map_id' := Œª X, by { ext i, exact embed.f_id _ },
  map_comp' := by { intros, ext i, exact embed.f_comp f g _ } }
.

instance embed_additive :
  (embed e : homological_complex ùíû cŒπ ‚•§ homological_complex ùíû cŒπ').additive :=
 { map_add' := Œª X Y f g, by { ext, exact embed.f_add _, }, }

def embed_iso (i : Œπ) : ((embed e).obj X).X (e.f i) ‚âÖ X.X i :=
eq_to_iso
begin
  delta embed embed.obj,
  dsimp,
  rw e.r_f,
  refl,
end

lemma embed_eval_is_zero_of_none (i' : Œπ') (hi' : e.r i' = none) :
  is_zero (embed e ‚ãô homological_complex.eval ùíû _ i') :=
begin
  rw functor.is_zero_iff,
  intro X,
  exact is_zero.of_iso (limits.is_zero_zero _) (embed.X_iso_of_none X hi'),
end

@[simps]
def embed_eval_iso_of_some (i' : Œπ') (i : Œπ) (hi' : e.r i' = some i) :
  embed e ‚ãô homological_complex.eval ùíû cŒπ' i' ‚âÖ homological_complex.eval ùíû cŒπ i :=
nat_iso.of_components (Œª X, embed.X_iso_of_some X hi')
  (Œª X‚ÇÅ X‚ÇÇ f, begin
    dsimp [embed, embed.map],
    rw embed.f_of_some f hi',
    simp only [category.assoc, iso.inv_hom_id, category.comp_id],
  end)

@[simp]
lemma embed_nat_obj_down_up_succ
  (C : chain_complex ùíû ‚Ñï) (i : ‚Ñï) :
  ((embed complex_shape.embedding.nat_down_int_up).obj C).X (-[1+i]) = C.X (i+1) := rfl

@[simp]
lemma embed_nat_obj_down_up_zero
  (C : chain_complex ùíû ‚Ñï) :
  ((embed complex_shape.embedding.nat_down_int_up).obj C).X 0 = C.X 0 := rfl

@[simp]
lemma embed_nat_obj_down_up_pos
  (C : chain_complex ùíû ‚Ñï) (i : ‚Ñï) :
  ((embed complex_shape.embedding.nat_down_int_up).obj C).X (i+1) = 0 := rfl

@[simp]
lemma embed_nat_obj_down_up_succ_f
  (C‚ÇÅ C‚ÇÇ : chain_complex ùíû ‚Ñï) (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) (i : ‚Ñï) :
  ((embed complex_shape.embedding.nat_down_int_up).map f).f (-[1+i]) = f.f (i+1) := rfl

@[simp]
lemma embed_nat_obj_down_up_zero_f
  (C‚ÇÅ C‚ÇÇ : chain_complex ùíû ‚Ñï) (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) :
  ((embed complex_shape.embedding.nat_down_int_up).map f).f 0 = f.f 0 := rfl

@[simp]
lemma embed_nat_obj_down_up_zero_pos
  (C‚ÇÅ C‚ÇÇ : chain_complex ùíû ‚Ñï) (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) (i : ‚Ñï) :
  ((embed complex_shape.embedding.nat_down_int_up).map f).f (i+1) = 0 := rfl

end embedding_change_of_complex

section homotopy

variables {X Y : homological_complex ùíû cŒπ}

variables (f f' : X ‚ü∂ Y) (h : homotopy f f')

/-- The morphism `h·µ¢‚±º: X·µ¢ ‚ü∂ Y‚±º` coming from a homotopy between two morphisms of type `X ‚ü∂ Y`.
  Here `X` and `Y` are complexes of shape `Œπ` and the indices `i j` run over `option Œπ`. -/
def embed_homotopy_hom : Œ† (i j : option Œπ), embed.X X i ‚ü∂ embed.X Y j
| (some i) (some j) := h.hom i j
| (some i) none     := 0
| none     j        := 0

@[simp] lemma embed_homotopy_hom_some (i j : Œπ) :
  embed_homotopy_hom f f' h (some i) (some j) = h.hom i j := rfl

@[simp] lemma embed_homotopy_hom_eq_zero_of_to_none (oi : option Œπ) :
  embed_homotopy_hom f f' h oi none = 0 := by cases oi; refl

@[simp] lemma embed_homotopy_hom_eq_zero_of_of_none (oi : option Œπ) :
  embed_homotopy_hom f f' h none oi = 0 := rfl

lemma embed_homotopy_zero : Œ† (oi oj : option Œπ)
  (H : ‚àÄ (i j : Œπ), oi = some i ‚Üí oj = some j ‚Üí ¬¨ cŒπ.rel j i),
  embed_homotopy_hom f f' h oi oj = 0
| (some i) (some j) H := h.zero i j $ H _ _ rfl rfl
| (some i) none     H := rfl
| none     j        H := rfl

def embed_homotopy (e : cŒπ.embedding cŒπ') :
  homotopy ((embed e).map f) ((embed e).map f') :=
{ hom := Œª i j, embed_homotopy_hom f f' h (e.r i) (e.r j),
  zero' := Œª i j hij, embed_homotopy_zero f f' h _ _ begin
    simp only [e.eq_some],
    rintro i' j' rfl rfl h',
    exact hij (e.c h')
  end,
  comm := Œª i', begin
    by_cases hi : ‚àÉ i : Œπ, i' = e.f i,
    { rcases hi with ‚ü®i, rfl‚ü©,
      delta embed embed.map embed.obj embed.X embed.d embed.f
        embed_homotopy_hom d_next prev_d id_rhs,
      dsimp only [add_monoid_hom.mk'_apply],
      rw e.r_f i,
      dsimp only,
      rw h.comm i,
      delta d_next prev_d id_rhs,
      dsimp only [add_monoid_hom.mk'_apply],
      rw add_left_inj,
      congr' 1,
      { by_cases aux : ‚àÉ j, cŒπ.rel i j,
        { rcases aux with ‚ü®j, hj‚ü©,
          rw [cŒπ.next_eq' hj, cŒπ'.next_eq' (e.c hj), e.r_f] },
        { push_neg at aux,
          induction x : e.r (cŒπ'.next (e.f i));
          simp only [X.shape _ _ (aux _), zero_comp], } },
      { by_cases aux : ‚àÉ j, cŒπ.rel j i,
        { rcases aux with ‚ü®j, hj‚ü©,
          rw [cŒπ.prev_eq' hj, cŒπ'.prev_eq' (e.c hj), e.r_f] },
        { push_neg at aux,
          induction x : e.r (cŒπ'.prev (e.f i));
          simp only [Y.shape _ _ (aux _), comp_zero], } } },
    { -- i' not in image
      have foo := e.r_none _ hi,
      suffices : subsingleton (embed.X X (e.r i') ‚ü∂ embed.X Y (e.r i')),
      { refine @subsingleton.elim _ this _ _ },
      convert (homological_complex.embed.subsingleton_of_none X _), },
  end }

end homotopy

section homology_comparison

def congr_eval (ùìê : Type*) [category ùìê] [preadditive ùìê] (c‚ÇÅ : complex_shape Œπ‚ÇÅ) (i j : Œπ‚ÇÅ)
  (h : i = j) : eval ùìê c‚ÇÅ i ‚âÖ eval ùìê c‚ÇÅ j := eq_to_iso (by rw h)

def congr_prev_functor (ùìê : Type*) [category ùìê] [abelian ùìê] (c‚ÇÅ : complex_shape Œπ‚ÇÅ) (i j : Œπ‚ÇÅ)
  (h : i = j) : prev_functor ùìê c‚ÇÅ i ‚âÖ prev_functor ùìê c‚ÇÅ j := eq_to_iso (by rw h)

def congr_next_functor (ùìê : Type*) [category ùìê] [abelian ùìê] (c‚ÇÅ : complex_shape Œπ‚ÇÅ) (i j : Œπ‚ÇÅ)
  (h : i = j) : next_functor ùìê c‚ÇÅ i ‚âÖ next_functor ùìê c‚ÇÅ j := eq_to_iso (by rw h)

def embed_comp_eval (ùìê : Type*) [category ùìê] [preadditive ùìê] [has_zero_object ùìê]
  {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (i‚ÇÅ : Œπ‚ÇÅ) :
  embed e ‚ãô eval ùìê c‚ÇÇ (e.f i‚ÇÅ) ‚âÖ eval ùìê c‚ÇÅ i‚ÇÅ :=
nat_iso.of_components
(Œª X, embed.X_iso_of_some X (e.r_f i‚ÇÅ))
(Œª X Y f, begin
  dsimp [embed, embed.map],
  rw embed.f_of_some f (e.r_f i‚ÇÅ),
  simp only [category.assoc, iso.inv_hom_id, category.comp_id],
end)

/-
def embed_comp_prev_functor (ùìê : Type*) [category ùìê] [abelian ùìê]
  {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (he : e.c_iff) (i‚ÇÅ : Œπ‚ÇÅ) :
  embed e ‚ãô prev_functor ùìê c‚ÇÇ (e.f i‚ÇÅ) ‚âÖ prev_functor ùìê c‚ÇÅ i‚ÇÅ :=
begin
  rcases h‚ÇÅ : c‚ÇÅ.prev i‚ÇÅ with _ | ‚ü®j, hj‚ü©,
  { apply is_zero.iso,
    { rcases h‚ÇÇ : c‚ÇÇ.prev (e.f i‚ÇÅ) with _ | ‚ü®k, hk‚ü©,
      { apply functor.is_zero_of_comp,
        exact prev_functor_is_zero _ _ _ h‚ÇÇ, },
      { rw is_zero.iff_id_eq_zero,
        ext X,
        apply is_zero.eq_of_src,
        dsimp,
        refine is_zero.of_iso _ (((embed e).obj X).X_prev_iso hk),
        dsimp [embed, embed.obj],
        apply embed.X_is_zero_of_none X,
        apply e.r_none,
        rintro ‚ü®i, hi‚ü©,
        rw [hi, ‚Üê he] at hk,
        rw c‚ÇÅ.prev_eq_some hk at h‚ÇÅ,
        simpa only using h‚ÇÅ, }, },
    { exact prev_functor_is_zero _ _ _ h‚ÇÅ, }, },
  { exact iso_whisker_left (embed e) (prev_functor_iso_eval ùìê c‚ÇÇ (e.f i‚ÇÅ) (e.f j) (e.c hj)) ‚â™‚â´
       embed_comp_eval ùìê e j ‚â™‚â´
       (prev_functor_iso_eval ùìê c‚ÇÅ i‚ÇÅ j hj).symm, }
end

def embed_comp_next_functor (ùìê : Type*) [category ùìê] [abelian ùìê]
  {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (he : e.c_iff) (i‚ÇÅ : Œπ‚ÇÅ) :
  embed e ‚ãô next_functor ùìê c‚ÇÇ (e.f i‚ÇÅ) ‚âÖ next_functor ùìê c‚ÇÅ i‚ÇÅ :=
begin
  rcases h‚ÇÅ : c‚ÇÅ.next i‚ÇÅ with _ | ‚ü®j, hj‚ü©,
  { apply is_zero.iso,
    { rcases h‚ÇÇ : c‚ÇÇ.next (e.f i‚ÇÅ) with _ | ‚ü®k, hk‚ü©,
      { apply functor.is_zero_of_comp,
        exact next_functor_is_zero _ _ _ h‚ÇÇ, },
      { rw is_zero.iff_id_eq_zero,
        ext X,
        apply is_zero.eq_of_src,
        dsimp,
        refine is_zero.of_iso _ (((embed e).obj X).X_next_iso hk),
        dsimp [embed, embed.obj],
        apply embed.X_is_zero_of_none X,
        apply e.r_none,
        rintro ‚ü®i, hi‚ü©,
        rw [hi, ‚Üê he] at hk,
        rw c‚ÇÅ.next_eq_some hk at h‚ÇÅ,
        simpa only using h‚ÇÅ,}, },
    { exact next_functor_is_zero _ _ _ h‚ÇÅ, }, },
  { exact iso_whisker_left (embed e) (next_functor_iso_eval ùìê c‚ÇÇ (e.f i‚ÇÅ) (e.f j) (e.c hj)) ‚â™‚â´
       embed_comp_eval ùìê e j ‚â™‚â´
       (next_functor_iso_eval ùìê c‚ÇÅ i‚ÇÅ j hj).symm }
end

def embed_short_complex_functor_homological_complex_œÄ‚ÇÅ (ùìê : Type*) [category ùìê] [abelian ùìê]
  {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (he : e.c_iff)
  (i‚ÇÅ : Œπ‚ÇÅ) (i‚ÇÇ : Œπ‚ÇÇ) (h‚ÇÅ‚ÇÇ : e.f i‚ÇÅ = i‚ÇÇ) :
  (embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ) ‚ãô short_complex.œÄ‚ÇÅ ‚âÖ
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ ‚ãô short_complex.œÄ‚ÇÅ :=
functor.associator _ _ _ ‚â™‚â´
  iso_whisker_left (embed e)
    (short_complex.functor_homological_complex_œÄ‚ÇÅ_iso_prev_functor ùìê c‚ÇÇ i‚ÇÇ) ‚â™‚â´
  (iso_whisker_left (embed e) (congr_prev_functor ùìê c‚ÇÇ i‚ÇÇ (e.f i‚ÇÅ) h‚ÇÅ‚ÇÇ.symm)) ‚â™‚â´
  embed_comp_prev_functor ùìê e he i‚ÇÅ ‚â™‚â´
  (short_complex.functor_homological_complex_œÄ‚ÇÅ_iso_prev_functor ùìê c‚ÇÅ i‚ÇÅ).symm

def embed_short_complex_functor_homological_complex_œÄ‚ÇÇ (ùìê : Type*) [category ùìê] [abelian ùìê]
  {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (i‚ÇÅ : Œπ‚ÇÅ) (i‚ÇÇ : Œπ‚ÇÇ)
  (h‚ÇÅ‚ÇÇ : e.f i‚ÇÅ = i‚ÇÇ) :
  (embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ) ‚ãô short_complex.œÄ‚ÇÇ ‚âÖ
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ ‚ãô short_complex.œÄ‚ÇÇ :=
functor.associator _ _ _ ‚â™‚â´
  iso_whisker_left (embed e)
    (short_complex.functor_homological_complex_œÄ‚ÇÇ_iso_eval ùìê c‚ÇÇ i‚ÇÇ) ‚â™‚â´
  (iso_whisker_left (embed e) (congr_eval ùìê c‚ÇÇ i‚ÇÇ (e.f i‚ÇÅ) h‚ÇÅ‚ÇÇ.symm)) ‚â™‚â´
  embed_comp_eval ùìê e i‚ÇÅ ‚â™‚â´
  (short_complex.functor_homological_complex_œÄ‚ÇÇ_iso_eval ùìê c‚ÇÅ i‚ÇÅ).symm

def embed_short_complex_functor_homological_complex_œÄ‚ÇÉ (ùìê : Type*) [category ùìê] [abelian ùìê]
  {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (he : e.c_iff)
  (i‚ÇÅ : Œπ‚ÇÅ) (i‚ÇÇ : Œπ‚ÇÇ) (h‚ÇÅ‚ÇÇ : e.f i‚ÇÅ = i‚ÇÇ) :
  (embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ) ‚ãô short_complex.œÄ‚ÇÉ ‚âÖ
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ ‚ãô short_complex.œÄ‚ÇÉ :=
functor.associator _ _ _ ‚â™‚â´
  iso_whisker_left (embed e)
    (short_complex.functor_homological_complex_œÄ‚ÇÉ_iso_next_functor ùìê c‚ÇÇ i‚ÇÇ) ‚â™‚â´
  (iso_whisker_left (embed e) (congr_next_functor ùìê c‚ÇÇ i‚ÇÇ (e.f i‚ÇÅ) h‚ÇÅ‚ÇÇ.symm)) ‚â™‚â´
  embed_comp_next_functor ùìê e he i‚ÇÅ ‚â™‚â´
  (short_complex.functor_homological_complex_œÄ‚ÇÉ_iso_next_functor ùìê c‚ÇÅ i‚ÇÅ).symm

lemma embed_d_to (ùìê : Type*) [category ùìê] [abelian ùìê]
  {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (he : e.c_iff)
  (i‚ÇÅ : Œπ‚ÇÅ) (X : homological_complex ùìê c‚ÇÅ) :
  ((embed e).obj X).d_to (e.f i‚ÇÅ) ‚â´ (embed.X_iso_of_some X (e.r_f i‚ÇÅ)).hom =
  (embed_comp_prev_functor ùìê e he i‚ÇÅ).hom.app X ‚â´ X.d_to i‚ÇÅ :=
begin
  dsimp [embed_comp_prev_functor],
  rcases h‚ÇÅ : c‚ÇÅ.prev i‚ÇÅ with _ | ‚ü®j, hj‚ü©,
  { simp only [h‚ÇÅ, d_to_eq_zero, comp_zero, preadditive.is_iso.comp_right_eq_zero],
    rcases h‚ÇÇ : c‚ÇÇ.prev (e.f i‚ÇÅ) with _ | ‚ü®k, hk‚ü©,
    { apply is_zero.eq_of_src,
      exact is_zero.of_iso (limits.is_zero_zero _) (((embed e).obj X).X_prev_iso_zero h‚ÇÇ), },
    { simp only [homological_complex.d_to_eq _ hk, preadditive.is_iso.comp_left_eq_zero],
      dsimp [embed, embed.obj, embed.d],
      rcases h‚ÇÉ : e.r k with _ | l,
      { refl, },
      { rw e.r_f i‚ÇÅ,
        dsimp [embed.d],
        by_cases h‚ÇÑ : c‚ÇÅ.rel l i‚ÇÅ,
        { exfalso,
          simpa only [c‚ÇÅ.prev_eq_some h‚ÇÑ] using h‚ÇÅ, },
        { exact X.shape _ _ h‚ÇÑ, }, }, }, },
  { simp only [h‚ÇÅ, homological_complex.d_to_eq _ hj,
      homological_complex.d_to_eq _ (e.c hj)],
    conv_lhs { congr, congr, skip, dsimp [embed, embed.obj, embed.d], },
    rw embed.d_of_some_of_some X (e.r_f j) (e.r_f i‚ÇÅ),
    dsimp [iso_whisker_left, prev_functor_iso_eval, embed_comp_eval, nat_iso.of_components],
    simp only [category.assoc, iso.inv_hom_id, category.comp_id, iso.inv_hom_id_assoc], },
end

lemma embed_d_from (ùìê : Type*) [category ùìê] [abelian ùìê]
  {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (he : e.c_iff)
  (i‚ÇÅ : Œπ‚ÇÅ) (X : homological_complex ùìê c‚ÇÅ) :
  ((embed e).obj X).d_from (e.f i‚ÇÅ) ‚â´ (embed_comp_next_functor ùìê e he i‚ÇÅ).hom.app X =
  (embed.X_iso_of_some X (e.r_f i‚ÇÅ)).hom ‚â´ X.d_from i‚ÇÅ :=
begin
  dsimp [embed_comp_next_functor],
  rcases h‚ÇÅ : c‚ÇÅ.next i‚ÇÅ with _ | ‚ü®j, hj‚ü©,
  { simp only [h‚ÇÅ, d_from_eq_zero, comp_zero, preadditive.is_iso.comp_right_eq_zero],
    rcases h‚ÇÇ : c‚ÇÇ.next (e.f i‚ÇÅ) with _ | ‚ü®k, hk‚ü©,
    { apply is_zero.eq_of_tgt,
      exact is_zero.of_iso (limits.is_zero_zero _) (((embed e).obj X).X_next_iso_zero h‚ÇÇ), },
    { simp only [homological_complex.d_from_eq _ hk, preadditive.is_iso.comp_right_eq_zero],
      dsimp [embed, embed.obj, embed.d],
      rcases h‚ÇÉ : e.r k with _ | l,
      { exact embed.d_of_none_tgt X rfl, },
      { rw e.r_f i‚ÇÅ,
        dsimp [embed.d],
        by_cases h‚ÇÑ : c‚ÇÅ.rel i‚ÇÅ l,
        { exfalso,
          simpa only [c‚ÇÅ.next_eq_some h‚ÇÑ] using h‚ÇÅ, },
        { exact X.shape _ _ h‚ÇÑ, }, }, }, },
  { simp only [h‚ÇÅ, homological_complex.d_from_eq _ hj,
      homological_complex.d_from_eq _ (e.c hj)],
    conv_lhs { congr, congr, dsimp [embed, embed.obj, embed.d], },
    rw embed.d_of_some_of_some X (e.r_f i‚ÇÅ) (e.r_f j),
    dsimp [iso_whisker_left, next_functor_iso_eval, embed_comp_eval, nat_iso.of_components],
    simp only [category.assoc, eq_to_hom_trans, eq_to_hom_refl, category.comp_id,
      iso.inv_hom_id_assoc], },
end

def embed_short_complex_functor_homological_complex (ùìê : Type*) [category ùìê] [abelian ùìê]
  {c‚ÇÅ : complex_shape Œπ‚ÇÅ} {c‚ÇÇ : complex_shape Œπ‚ÇÇ} (e : c‚ÇÅ.embedding c‚ÇÇ) (he : e.c_iff)
  (i‚ÇÅ : Œπ‚ÇÅ) (i‚ÇÇ : Œπ‚ÇÇ) (h‚ÇÅ‚ÇÇ : e.f i‚ÇÅ = i‚ÇÇ) :
  embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ ‚âÖ
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ :=
begin
  refine short_complex.functor_nat_iso_mk
    (embed_short_complex_functor_homological_complex_œÄ‚ÇÅ ùìê e he i‚ÇÅ i‚ÇÇ h‚ÇÅ‚ÇÇ)
    (embed_short_complex_functor_homological_complex_œÄ‚ÇÇ ùìê e i‚ÇÅ i‚ÇÇ h‚ÇÅ‚ÇÇ)
    (embed_short_complex_functor_homological_complex_œÄ‚ÇÉ ùìê e he i‚ÇÅ i‚ÇÇ h‚ÇÅ‚ÇÇ) _ _,
  { subst h‚ÇÅ‚ÇÇ,
    ext X,
    dsimp [nat_trans.hcomp, embed_short_complex_functor_homological_complex_œÄ‚ÇÇ,
      short_complex.functor_homological_complex_œÄ‚ÇÇ_iso_eval,
      embed_short_complex_functor_homological_complex_œÄ‚ÇÅ, congr_eval,
      congr_prev_functor, embed_comp_eval, iso.refl,
      short_complex.functor_homological_complex_œÄ‚ÇÅ_iso_prev_functor],
    simp only [category.assoc],
    erw [nat_trans.id_app, nat_trans.id_app],
    repeat { erw category.id_comp, },
    repeat { erw category.comp_id, },
    apply embed_d_to, },
  { subst h‚ÇÅ‚ÇÇ,
    ext X,
    dsimp [nat_trans.hcomp, embed_short_complex_functor_homological_complex_œÄ‚ÇÇ,
      short_complex.functor_homological_complex_œÄ‚ÇÇ_iso_eval,
      embed_short_complex_functor_homological_complex_œÄ‚ÇÉ, congr_eval,
      congr_prev_functor, embed_comp_eval, iso.refl,
      short_complex.functor_homological_complex_œÄ‚ÇÉ_iso_next_functor],
    simp only [category.assoc],
    erw [nat_trans.id_app, nat_trans.id_app],
    repeat { erw category.id_comp, },
    repeat { erw category.comp_id, },
    apply embed_d_from, },
end
-/

variables (ùìê : Type*) [category ùìê] [abelian ùìê] (e : c‚ÇÅ.embedding c‚ÇÇ)
  (i‚ÇÅ : Œπ‚ÇÅ) (i‚ÇÇ : Œπ‚ÇÇ)

@[simp]
def embed_short_complex_œÄ‚ÇÅ_Œπ :
  embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ ‚ãô short_complex.œÄ‚ÇÅ ‚ü∂
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ ‚ãô short_complex.œÄ‚ÇÅ :=
begin
  by_cases e.r (c‚ÇÇ.prev i‚ÇÇ) = some (c‚ÇÅ.prev i‚ÇÅ),
  { exact (embed_eval_iso_of_some e _ _ h).hom, },
  { exact 0, },
end

@[simp]
def embed_short_complex_œÄ‚ÇÇ_iso (h‚ÇÅ‚ÇÇ : e.f i‚ÇÅ = i‚ÇÇ) :
  embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ ‚ãô short_complex.œÄ‚ÇÇ ‚âÖ
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ ‚ãô short_complex.œÄ‚ÇÇ :=
embed_eval_iso_of_some e i‚ÇÇ i‚ÇÅ (by { rw [‚Üê h‚ÇÅ‚ÇÇ, e.r_f],})

@[simp]
def embed_short_complex_œÄ‚ÇÉ_Œπ :
  embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ ‚ãô short_complex.œÄ‚ÇÉ ‚ü∂
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ ‚ãô short_complex.œÄ‚ÇÉ :=
begin
  by_cases e.r (c‚ÇÇ.next i‚ÇÇ) = some (c‚ÇÅ.next i‚ÇÅ),
  { exact (embed_eval_iso_of_some e _ _ h).hom, },
  { exact 0, },
end

-- @[simps]
def embed_short_complex_Œπ (h‚ÇÅ‚ÇÇ : e.f i‚ÇÅ = i‚ÇÇ) :
  embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ ‚ü∂
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ :=
short_complex.nat_trans_hom_mk
  (embed_short_complex_œÄ‚ÇÅ_Œπ ùìê e _ _)
  (embed_short_complex_œÄ‚ÇÇ_iso ùìê e _ _ h‚ÇÅ‚ÇÇ).hom
  (embed_short_complex_œÄ‚ÇÉ_Œπ ùìê e _ _)
begin
  ext X,
  subst h‚ÇÅ‚ÇÇ,
  show (((embed e).obj X).d_to (e.f i‚ÇÅ) ‚â´ ùüô (((embed e).obj X).X (e.f i‚ÇÅ))) ‚â´ (embed.X_iso_of_some X _).hom =
    (embed_short_complex_œÄ‚ÇÅ_Œπ ùìê e i‚ÇÅ (e.f i‚ÇÅ)).app X ‚â´ X.d_to i‚ÇÅ ‚â´ ùüô (X.X i‚ÇÅ),
  simp only [embed_short_complex_œÄ‚ÇÅ_Œπ, category.comp_id],
  split_ifs with h,
  { show embed.d X (e.r (c‚ÇÇ.prev (e.f i‚ÇÅ))) (e.r (e.f i‚ÇÅ)) ‚â´ (embed.X_iso_of_some X _).hom =
      (embed.X_iso_of_some X h).hom ‚â´ X.d (c‚ÇÅ.prev i‚ÇÅ) i‚ÇÅ,
    simp only [embed.d_of_some_of_some X h (e.r_f i‚ÇÅ),
      category.assoc, iso.inv_hom_id, category.comp_id], },
  { suffices : ((embed e).obj X).d_to (e.f i‚ÇÅ) = 0,
    { simp only [this, nat_trans.app_zero, zero_comp], },
    rcases h‚ÇÇ : e.r (c‚ÇÇ.prev (e.f i‚ÇÅ)) with _ | j,
    { apply is_zero.eq_of_src,
      apply embed.X_is_zero_of_none,
      exact h‚ÇÇ, },
    { show embed.d X (e.r (c‚ÇÇ.prev (e.f i‚ÇÅ))) (e.r (e.f i‚ÇÅ)) = 0,
      by_contra h',
      rcases embed.d_ne_zero _ _ _ h' with ‚ü®i, k, h‚ÇÉ, h‚ÇÑ, h‚ÇÖ‚ü©,
      rw e.r_f at h‚ÇÑ,
      rw h‚ÇÇ at h‚ÇÉ,
      simp only at h‚ÇÑ h‚ÇÉ,
      substs h‚ÇÉ h‚ÇÑ,
      have h‚ÇÖ' : c‚ÇÅ.rel j i‚ÇÅ,
      { by_contra h‚ÇÖ'',
        exact h‚ÇÖ (X.shape _ _ h‚ÇÖ''), },
      rw c‚ÇÅ.prev_eq' h‚ÇÖ' at h,
      exact h h‚ÇÇ, }, },
end
begin
  ext X,
  show (((embed e).obj X).d_from i‚ÇÇ ‚â´ ùüô (((embed e).obj X).X_next i‚ÇÇ)) ‚â´ _ =
    (embed.X_iso_of_some X _).hom ‚â´ X.d_from i‚ÇÅ ‚â´ ùüô (X.X_next i‚ÇÅ),
  dsimp only [embed_short_complex_œÄ‚ÇÉ_Œπ],
  subst h‚ÇÅ‚ÇÇ,
  split_ifs with h,
  { simp only [category.comp_id],
    show embed.d X (e.r (e.f i‚ÇÅ)) (e.r (c‚ÇÇ.next (e.f i‚ÇÅ))) ‚â´ (embed.X_iso_of_some X h).hom =
      (embed.X_iso_of_some X _).hom ‚â´ X.d_from i‚ÇÅ,
    simp only [embed.d_of_some_of_some X (e.r_f i‚ÇÅ) h,
      category.assoc, iso.inv_hom_id, category.comp_id], },
  { suffices : X.d i‚ÇÅ (c‚ÇÅ.next i‚ÇÅ) = 0,
    { delta d_from, simp only [this, zero_comp, comp_zero, nat_trans.app_zero], },
    apply X.shape,
    rw e.eq_some at h,
    contrapose! h,
    rw c‚ÇÇ.next_eq' (e.c h) },
end
.

@[simp]
def embed_short_complex_œÄ‚ÇÅ_œÄ :
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ ‚ãô short_complex.œÄ‚ÇÅ ‚ü∂
  embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ ‚ãô short_complex.œÄ‚ÇÅ :=
begin
  by_cases e.r (c‚ÇÇ.prev i‚ÇÇ) = some (c‚ÇÅ.prev i‚ÇÅ),
  { exact (embed_eval_iso_of_some e _ _ h).inv, },
  { exact 0, },
end

@[simp]
def embed_short_complex_œÄ‚ÇÉ_œÄ :
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ ‚ãô short_complex.œÄ‚ÇÉ ‚ü∂
  embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ ‚ãô short_complex.œÄ‚ÇÉ :=
begin
  by_cases e.r (c‚ÇÇ.next i‚ÇÇ) = some (c‚ÇÅ.next i‚ÇÅ),
  { exact (embed_eval_iso_of_some e _ _ h).inv, },
  { exact 0, },
end

@[simps]
def embed_short_complex_œÄ (h‚ÇÅ‚ÇÇ : e.f i‚ÇÅ = i‚ÇÇ) :
  short_complex.functor_homological_complex ùìê c‚ÇÅ i‚ÇÅ ‚ü∂
  embed e ‚ãô short_complex.functor_homological_complex ùìê c‚ÇÇ i‚ÇÇ :=
short_complex.nat_trans_hom_mk
  (embed_short_complex_œÄ‚ÇÅ_œÄ ùìê e _ _)
  (embed_short_complex_œÄ‚ÇÇ_iso ùìê e _ _ h‚ÇÅ‚ÇÇ).inv
  (embed_short_complex_œÄ‚ÇÉ_œÄ ùìê e _ _)
begin
  ext X,
  show (X.d_to i‚ÇÅ ‚â´ ùüô (X.X i‚ÇÅ)) ‚â´ (embed.X_iso_of_some X _).inv =
    _ ‚â´ ((embed e).obj X).d_to i‚ÇÇ ‚â´ ùüô (((embed e).obj X).X i‚ÇÇ),
  dsimp only [embed_short_complex_œÄ‚ÇÅ_œÄ],
  subst h‚ÇÅ‚ÇÇ,
  split_ifs with h,
  { simp only [category.comp_id],
    show X.d (c‚ÇÅ.prev i‚ÇÅ) i‚ÇÅ ‚â´ (embed.X_iso_of_some X _).inv =
      (embed.X_iso_of_some X h).inv ‚â´ embed.d X (e.r (c‚ÇÇ.prev (e.f i‚ÇÅ))) (e.r (e.f i‚ÇÅ)),
    simp only [embed.d_of_some_of_some X h (e.r_f i‚ÇÅ), category.assoc, iso.inv_hom_id_assoc], },
  { suffices : X.d (c‚ÇÅ.prev i‚ÇÅ) i‚ÇÅ = 0,
    { delta d_to, simp only [this, zero_comp, nat_trans.app_zero], },
    apply X.shape,
    rw e.eq_some at h,
    contrapose! h,
    rw c‚ÇÇ.prev_eq' (e.c h) },
end
begin
  ext X,
  show (X.d_from i‚ÇÅ ‚â´ ùüô (X.X_next i‚ÇÅ)) ‚â´ _ =
    (embed.X_iso_of_some X _).inv ‚â´ ((embed e).obj X).d_from i‚ÇÇ ‚â´ ùüô (((embed e).obj X).X_next i‚ÇÇ),
  dsimp only [embed_short_complex_œÄ‚ÇÉ_œÄ],
  subst h‚ÇÅ‚ÇÇ,
  split_ifs with h,
  { simp only [category.comp_id],
    show X.d i‚ÇÅ (c‚ÇÅ.next i‚ÇÅ) ‚â´ (embed.X_iso_of_some X h).inv =
      (embed.X_iso_of_some X _).inv ‚â´ embed.d X (e.r (e.f i‚ÇÅ)) (e.r (c‚ÇÇ.next (e.f i‚ÇÅ))),
    simp only [embed.d_of_some_of_some X (e.r_f i‚ÇÅ) h, category.assoc, iso.inv_hom_id_assoc], },
  { suffices : ((embed e).obj X).d_from (e.f i‚ÇÅ) = 0,
    { simp only [this, nat_trans.app_zero, zero_comp, comp_zero], },
    rcases h‚ÇÇ : e.r (c‚ÇÇ.next (e.f i‚ÇÅ)) with _ | j,
    { apply is_zero.eq_of_tgt,
      apply embed.X_is_zero_of_none,
      exact h‚ÇÇ, },
    { show embed.d X (e.r (e.f i‚ÇÅ)) (e.r (c‚ÇÇ.next (e.f i‚ÇÅ))) = 0,
      by_contra h',
      rcases embed.d_ne_zero _ _ _ h' with ‚ü®i, k, h‚ÇÉ, h‚ÇÑ, h‚ÇÖ‚ü©,
      rw e.r_f at h‚ÇÉ,
      rw h‚ÇÇ at h‚ÇÑ,
      simp only at h‚ÇÑ h‚ÇÉ,
      substs h‚ÇÉ h‚ÇÑ,
      have h‚ÇÖ' : c‚ÇÅ.rel i‚ÇÅ j,
      { by_contra h‚ÇÖ'',
        exact h‚ÇÖ (X.shape _ _ h‚ÇÖ''), },
      rw c‚ÇÅ.next_eq' h‚ÇÖ' at h,
      exact h h‚ÇÇ, }, },
end

def homology_embed_nat_iso (h‚ÇÅ‚ÇÇ : e.f i‚ÇÅ = i‚ÇÇ) :
  embed e ‚ãô homology_functor ùìê c‚ÇÇ i‚ÇÇ ‚âÖ homology_functor ùìê c‚ÇÅ i‚ÇÅ :=
{ hom := embed_short_complex_Œπ ùìê e i‚ÇÅ i‚ÇÇ h‚ÇÅ‚ÇÇ ‚ó´ (ùüô short_complex.homology_functor),
  inv := embed_short_complex_œÄ ùìê e i‚ÇÅ i‚ÇÇ h‚ÇÅ‚ÇÇ ‚ó´ (ùüô short_complex.homology_functor),
  hom_inv_id' := begin
    ext K : 2,
    simp only [nat_trans.comp_app, nat_trans.hcomp_id_app, nat_trans.id_app,
      ‚Üê functor.map_comp],
    apply short_complex.homology_functor_map_eq_id,
    simp only [short_complex.comp_œÑ‚ÇÇ],
    dsimp only [embed_short_complex_Œπ, embed_short_complex_œÄ],
    simpa only [short_complex.nat_trans_hom_mk_app_œÑ‚ÇÇ_eq,
      iso.hom_inv_id_app],
  end,
  inv_hom_id' := begin
    ext K : 2,
    simp only [nat_trans.comp_app, nat_trans.hcomp_id_app, nat_trans.id_app,
      ‚Üê functor.map_comp],
    apply short_complex.homology_functor_map_eq_id,
    simp only [short_complex.comp_œÑ‚ÇÇ],
    dsimp only [embed_short_complex_Œπ, embed_short_complex_œÄ],
    simpa only [short_complex.nat_trans_hom_mk_app_œÑ‚ÇÇ_eq,
      iso.inv_hom_id_app],
  end, }

end homology_comparison

end homological_complex

namespace chain_complex

def single‚ÇÄ_comp_embed_iso_single_component (X : ùíû) : Œ† (i : ‚Ñ§),
  ((single‚ÇÄ ùíû ‚ãô homological_complex.embed complex_shape.embedding.nat_down_int_up).obj X).X i ‚âÖ
    ((homological_complex.single ùíû (complex_shape.up ‚Ñ§) 0).obj X).X i
| 0       := iso.refl _
| (n+1:‚Ñï) := iso.refl _
| -[1+n]  := iso.refl _

def single‚ÇÄ_comp_embed_iso_single :
  single‚ÇÄ ùíû ‚ãô homological_complex.embed complex_shape.embedding.nat_down_int_up ‚âÖ
    homological_complex.single ùíû (complex_shape.up ‚Ñ§) 0 :=
nat_iso.of_components
  (Œª X, homological_complex.hom.iso_of_components
    (single‚ÇÄ_comp_embed_iso_single_component X)
    (by rintro ((_|i)|i) ((_|j)|j) hij; exact comp_zero.trans zero_comp.symm))
  begin
    intros X Y f,
    ext ((_|i)|i);
    refine (category.comp_id _).trans (eq.trans _ (category.id_comp _).symm);
    dsimp [homological_complex.single],
    { simp only [eq_self_iff_true, category.comp_id, category.id_comp, if_true, nat.cast_zero], refl },
    { rw dif_neg, swap, dec_trivial, refl },
    { rw dif_neg, swap, dec_trivial }
  end

end chain_complex
