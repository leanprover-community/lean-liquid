import category_theory.sites.sheaf

import for_mathlib.sheafification.multifork

namespace category_theory
namespace grothendieck_topology

open category_theory.limits

universes w v u
variables {C : Type u} [category.{v} C] (J : grothendieck_topology C)
variables {D : Type w} [category.{max v u} D] (P : C·µí·µñ ‚•§ D)

@[derive small_category]
def cover (X : C) := { S : sieve X // S ‚àà J X }

instance (X : C) : has_coe (J.cover X) (sieve X) := ‚ü®Œª S, S.1‚ü©

instance (X : C) : has_coe_to_fun (J.cover X) (Œª S, Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), Prop) :=
‚ü®Œª S Y f, (S : sieve X) f‚ü©

@[ext]
lemma cover.ext (X : C) (S T : J.cover X) (h : (S : sieve X) = T) : S = T :=
subtype.ext h

variable {J}
lemma cover.condition {X : C} (S : J.cover X) : (S : sieve X) ‚àà J X := S.2
variable (J)

@[simps]
def cover.map {X Y : C} (f : X ‚ü∂ Y) : J.cover Y ‚•§ J.cover X :=
{ obj := Œª S, ‚ü®(S : sieve Y).pullback f, J.pullback_stable _ S.condition‚ü©,
  map := Œª S T h, hom_of_le $ sieve.pullback_monotone _ $ le_of_hom h }

def cover.map_id (X : C) : cover.map J (ùüô X) ‚âÖ ùü≠ _ :=
nat_iso.of_components (Œª I, eq_to_iso $ by { ext, simp }) $ by tidy

def cover.map_comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
  cover.map J (f ‚â´ g) ‚âÖ cover.map J g ‚ãô cover.map J f :=
nat_iso.of_components (Œª I, eq_to_iso $ by { ext, simp }) $ by tidy

def cover.top (X : C) : J.cover X := ‚ü®‚ä§, J.top_mem _‚ü©

def cover.map_top {X Y : C} (f : X ‚ü∂ Y) :
  (cover.map J f).obj (cover.top _ _) ‚âÖ cover.top _ _ :=
eq_to_iso rfl

def cover.to_top (X : C) (S : J.cover X) : S ‚ü∂ cover.top _ _ :=
‚ü®‚ü®le_top‚ü©‚ü©

instance (X : C) : is_cofiltered (J.cover X) :=
{ cocone_objs := Œª A B, ‚ü®‚ü®A ‚äì B, J.intersection_covering A.condition B.condition‚ü©,
    hom_of_le inf_le_left, hom_of_le inf_le_right, by tauto‚ü©,
  cocone_maps := Œª A B f g, ‚ü®A, ùüô _, rfl‚ü©,
  nonempty := ‚ü®cover.top J X‚ü© }

variable {J}

@[ext]
structure cover.left {X : C} (S : J.cover X) : Type (max v u) :=
(Y : C)
(f : Y ‚ü∂ X)
(hf : S f)

@[ext]
structure cover.right {X : C} (S : J.cover X) : Type (max v u) :=
(Y‚ÇÅ Y‚ÇÇ Z : C)
(g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ)
(g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ)
(f‚ÇÅ : Y‚ÇÅ ‚ü∂ X)
(f‚ÇÇ : Y‚ÇÇ ‚ü∂ X)
(h‚ÇÅ : S f‚ÇÅ)
(h‚ÇÇ : S f‚ÇÇ)
(w : g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ)

def cover.left_map {X : C} {S T : J.cover X} (h : S ‚ü∂ T) : S.left ‚Üí T.left :=
Œª I, ‚ü®I.Y, I.f, le_of_hom h _ I.hf‚ü©

def cover.right_map {X : C} {S T : J.cover X} (h : S ‚ü∂ T) : S.right ‚Üí T.right :=
Œª I, ‚ü®I.Y‚ÇÅ, I.Y‚ÇÇ, I.Z, I.g‚ÇÅ, I.g‚ÇÇ, I.f‚ÇÅ, I.f‚ÇÇ, le_of_hom h _ I.h‚ÇÅ, le_of_hom h _ I.h‚ÇÇ, I.w‚ü©

def cover.fst {X : C} (S : J.cover X) : S.right ‚Üí S.left :=
Œª I, ‚ü®I.Y‚ÇÅ, I.f‚ÇÅ, I.h‚ÇÅ‚ü©

def cover.snd {X : C} (S : J.cover X) : S.right ‚Üí S.left :=
Œª I, ‚ü®I.Y‚ÇÇ, I.f‚ÇÇ, I.h‚ÇÇ‚ü©

def cover.map_left {X Y : C} (f : X ‚ü∂ Y) (S : J.cover Y) :
  ((cover.map J f).obj S).left ‚Üí S.left :=
Œª I, ‚ü®I.Y, I.f ‚â´ f, I.hf‚ü©

def cover.map_right {X Y : C} (f : X ‚ü∂ Y) (S : J.cover Y) :
  ((cover.map J f).obj S).right ‚Üí S.right :=
Œª I, ‚ü®I.Y‚ÇÅ, I.Y‚ÇÇ, I.Z, I.g‚ÇÅ, I.g‚ÇÇ, I.f‚ÇÅ ‚â´ f, I.f‚ÇÇ ‚â´ f, I.h‚ÇÅ, I.h‚ÇÇ, by simp [reassoc_of I.w]‚ü©

@[simp]
lemma cover.map_left_f {X Y : C} (f : X ‚ü∂ Y) (S : J.cover Y)
  (t : ((cover.map J f).obj S).left) :
  (cover.map_left f S t).f = t.f ‚â´ f := rfl

@[simp]
lemma cover.fst_right_map {X : C} {S T : J.cover X} (h : S ‚ü∂ T) (x : S.right) :
   (cover.left_map h) (cover.fst _ x) = cover.fst _ (cover.right_map h x) := rfl

@[simp]
lemma cover.snd_right_map {X : C} {S T : J.cover X} (h : S ‚ü∂ T) (x : S.right) :
   (cover.left_map h) (cover.snd _ x) = cover.snd _ (cover.right_map h x) := rfl

@[simp]
lemma cover.map_left_map {X Y : C} (f : X ‚ü∂ Y) (S T : J.cover Y) (h : S ‚ü∂ T)
  (t : ((cover.map J f).obj S).left) :
  cover.map_left f _ (cover.left_map ((cover.map J f).map h) t) =
  cover.left_map h (cover.map_left f _ t) := rfl

@[simp]
lemma cover.map_right_map {X Y : C} (f : X ‚ü∂ Y) (S T : J.cover Y) (h : S ‚ü∂ T)
  (t : ((cover.map J f).obj S).right) :
  cover.map_right f _ (cover.right_map ((cover.map J f).map h) t) =
  cover.right_map h (cover.map_right f _ t) := rfl

noncomputable theory

open opposite

def cover.index {X : C} (S : J.cover X) : multipair.index S.fst S.snd D :=
{ L := Œª I, P.obj (op I.Y),
  R := Œª I, P.obj (op I.Z),
  F := Œª I, P.map I.g‚ÇÅ.op,
  S := Œª I, P.map I.g‚ÇÇ.op }

def cover.multifork {X : C} (S : J.cover X) :
  multifork (S.index P) :=
multifork.of_Œπ _ (P.obj (op X)) (Œª I, P.map I.f.op) begin
  intros II,
  dsimp [cover.index],
  simp_rw [‚Üê P.map_comp, ‚Üê op_comp],
  congr' 2,
  apply II.w,
end

def cover.family_of_elements {X : C} (S : J.cover X) (K : multifork (S.index P)) :
  presieve.family_of_elements (P ‚ãô coyoneda.obj (op K.X)) S :=
Œª Y f hf, K.Œπ ‚ü®Y,f,hf‚ü©

lemma cover.compatible {X : C} (S : J.cover X) (K : multifork (S.index P)) :
  (S.family_of_elements P K).compatible :=
begin
  intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ w,
  dsimp [cover.family_of_elements],
  erw K.w (walking_multipair.hom.fst ‚ü®Y‚ÇÅ, Y‚ÇÇ, Z, g‚ÇÅ, g‚ÇÇ, f‚ÇÅ, f‚ÇÇ, h‚ÇÅ, h‚ÇÇ, w‚ü©),
  erw K.w (walking_multipair.hom.snd ‚ü®Y‚ÇÅ, Y‚ÇÇ, Z, g‚ÇÅ, g‚ÇÇ, f‚ÇÅ, f‚ÇÇ, h‚ÇÅ, h‚ÇÇ, w‚ü©),
end

def cover.diagram_obj {X : C} (S : J.cover X) [has_limits D] : D :=
multiequalizer (S.index P)

def cover.diagram_map [has_limits D] {X : C} (S T : J.cover X) (h : S ‚ü∂ T) :
  T.diagram_obj P ‚ü∂ S.diagram_obj P :=
multiequalizer.lift _
(Œª I, multiequalizer.Œπ _ (cover.left_map h I) ‚â´ P.map (ùüô _)) begin
  intros I,
  dsimp,
  simp only [functor.map_id, category.assoc],
  erw [category.id_comp, category.id_comp],
  apply multiequalizer.condition
end

variable (J)
def cover_diagram [has_limits D] (X : C) : (J.cover X)·µí·µñ ‚•§ D :=
{ obj := Œª I, I.unop.diagram_obj P,
  map := Œª _ _ h, cover.diagram_map P _ _ h.unop,
  map_id' := begin
    intros I,
    dsimp [cover.diagram_map],
    ext T,
    simp only [functor.map_id, multiequalizer.lift_Œπ, category.id_comp, category.comp_id],
    erw category.comp_id,
    congr' 1,
    tidy,
  end,
  map_comp' := begin
    intros A B C e h,
    dsimp [cover.diagram_map],
    ext T,
    simp only [functor.map_id, multiequalizer.lift_Œπ, multiequalizer.lift_Œπ_assoc, category.assoc],
    erw [category.comp_id, category.comp_id, category.comp_id],
    simpa,
  end }

def cover_diagram.map [has_limits D] {X Y : C} (f : X ‚ü∂ Y) :
   cover_diagram J P Y ‚ü∂ (cover.map J f).op ‚ãô cover_diagram J P X :=
{ app := Œª I, multiequalizer.lift _
    (Œª t, multiequalizer.Œπ _ (cover.map_left f _ t)) begin
      intros II,
      exact multiequalizer.condition _ (cover.map_right _ _ II),
    end,
  naturality' := begin
    intros A B h,
    dsimp [cover_diagram, cover.diagram_map],
    ext t,
    simp only [functor.map_id, multiequalizer.lift_Œπ, multiequalizer.lift_Œπ_assoc, category.assoc],
    erw [category.comp_id],
  end }

def plus_obj [has_limits D] [has_colimits D] (X : C) : D :=
colimit (J.cover_diagram P X)

def plus_map [has_limits D] [has_colimits D] {X Y : C} (f : X ‚ü∂ Y) :
J.plus_obj P Y ‚ü∂ J.plus_obj P X :=
colim_map (cover_diagram.map J P f) ‚â´ colimit.pre _ _

def plus [has_limits D] [has_colimits D] : C·µí·µñ ‚•§ D :=
{ obj := Œª X, plus_obj J P X.unop,
  map := Œª X Y f, plus_map J P f.unop,
  map_id' := begin
    intros X,
    ext I,
    dsimp [plus_map],
    simp only [colimit.Œπ_pre, Œπ_colim_map_assoc],
    let e : I ‚âÖ (cover.map J (ùüô (unop X))).op.obj I :=
      (nat_iso.op (cover.map_id J X.unop)).app I,
    erw [‚Üê colimit.w (J.cover_diagram P X.unop) e.inv, category.comp_id, ‚Üê category.assoc],
    convert category.id_comp _ using 1,
    congr' 1,
    dsimp [cover_diagram.map],
    ext,
    dsimp [cover_diagram, cover.diagram_map],
    simp only [functor.map_id, multiequalizer.lift_Œπ, category.id_comp,
      category.comp_id, category.assoc],
    erw [category.comp_id, multiequalizer.lift_Œπ],
    congr' 1,
    tidy,
  end,
  map_comp' := begin
    intros A B C e h,
    ext I,
    dsimp [plus_map],
    simp only [colimit.Œπ_pre_assoc, colimit.Œπ_pre, Œπ_colim_map_assoc, category.assoc],
    let e : (cover.map J h.unop).op.obj ((cover.map J e.unop).op.obj I) ‚âÖ
      (cover.map J (h.unop ‚â´ e.unop)).op.obj I :=
      (nat_iso.op (cover.map_comp J _ _)).app I,
    simp_rw [‚Üê colimit.w (J.cover_diagram P _) e.inv, ‚Üê category.assoc],
    congr' 1,
    ext,
    dsimp [cover_diagram.map, cover_diagram, cover.diagram_map],
    simp only [functor.map_id, multiequalizer.lift_Œπ, category.comp_id, category.assoc],
    erw [category.comp_id, multiequalizer.lift_Œπ],
    congr' 1,
    tidy,
  end }

def to_plus_app [has_limits D] [has_colimits D] (X : C) :
  P.obj (op X) ‚ü∂ plus_obj J P X :=
multiequalizer.lift ((cover.top J X).index P) (Œª I, P.map I.f.op)
  begin
    intros I,
    dsimp [cover.index],
    simp_rw [‚Üê P.map_comp, ‚Üê op_comp],
    congr' 2,
    apply I.w
  end
‚â´ colimit.Œπ (J.cover_diagram P X) (op $ cover.top _ _)

def to_plus [has_limits D] [has_colimits D] :
  P ‚ü∂ plus J P :=
{ app := Œª X, to_plus_app J P X.unop,
  naturality' := begin
    intros X Y f,
    dsimp [to_plus_app, plus, plus_map],
    simp,
    dsimp [cover_diagram.map],
    let e : (cover.map J f.unop).obj (cover.top J X.unop)
      ‚ü∂ cover.top J Y.unop := cover.to_top _ _ _,
    simp_rw [‚Üê colimit.w _ e.op, ‚Üê category.assoc],
    congr' 1,
    dsimp [cover_diagram, cover.diagram_map],
    ext,
    simp only [cover.map_left_f, functor.map_id,
      multiequalizer.lift_Œπ, op_comp, category.comp_id,
      quiver.hom.op_unop, functor.map_comp, category.assoc],
    erw [category.comp_id, multiequalizer.lift_Œπ],
    refl,
  end }

end grothendieck_topology
end category_theory
