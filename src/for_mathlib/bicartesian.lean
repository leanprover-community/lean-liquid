-- import for_mathlib.exact_seq3
-- import for_mathlib.salamander
-- .

-- open category_theory category_theory.limits

-- variables {ğ“ : Type*} [category ğ“] [abelian ğ“]

-- -- Consider the following diagram
-- variables {     Kvâ‚   Kvâ‚‚        : ğ“}
-- variables {Khâ‚  Aâ‚â‚   Aâ‚â‚‚  Qhâ‚   : ğ“}
-- variables {Khâ‚‚  Aâ‚‚â‚   Aâ‚‚â‚‚  Qhâ‚‚   : ğ“}
-- variables {     Qvâ‚   Qvâ‚‚        : ğ“}
-- -- with morphisms
-- variables                         (fKv : Kvâ‚ âŸ¶ Kvâ‚‚)
-- variables                 {Î¹vâ‚ : Kvâ‚ âŸ¶ Aâ‚â‚} {Î¹vâ‚‚ : Kvâ‚‚ âŸ¶ Aâ‚â‚‚}
-- variables         {Î¹hâ‚ : Khâ‚ âŸ¶ Aâ‚â‚} {fâ‚ : Aâ‚â‚ âŸ¶ Aâ‚â‚‚} {Ï€hâ‚ : Aâ‚â‚‚ âŸ¶ Qhâ‚}
-- variables (gKh : Khâ‚ âŸ¶ Khâ‚‚) {gâ‚ : Aâ‚â‚ âŸ¶ Aâ‚‚â‚} {gâ‚‚ : Aâ‚â‚‚ âŸ¶ Aâ‚‚â‚‚} (gQh : Qhâ‚ âŸ¶ Qhâ‚‚)
-- variables         {Î¹hâ‚‚ : Khâ‚‚ âŸ¶ Aâ‚‚â‚} {fâ‚‚ : Aâ‚‚â‚ âŸ¶ Aâ‚‚â‚‚} {Ï€hâ‚‚ : Aâ‚‚â‚‚ âŸ¶ Qhâ‚‚}
-- variables                 {Ï€vâ‚ : Aâ‚‚â‚ âŸ¶ Qvâ‚}  {Ï€vâ‚‚ : Aâ‚‚â‚‚ âŸ¶ Qvâ‚‚}
-- variables                         (fQv : Qvâ‚ âŸ¶ Qvâ‚‚)
-- -- with exact rows and columns
-- variables (Hâ‚ : exact_seq ğ“ [Î¹hâ‚, fâ‚, Ï€hâ‚])
-- variables (Hâ‚‚ : exact_seq ğ“ [Î¹hâ‚‚, fâ‚‚, Ï€hâ‚‚])
-- variables (Vâ‚ : exact_seq ğ“ [Î¹vâ‚, gâ‚, Ï€vâ‚])
-- variables (Vâ‚‚ : exact_seq ğ“ [Î¹vâ‚‚, gâ‚‚, Ï€vâ‚‚])
-- -- and such that all the extremal maps are appropriately monos or epis
-- variables [mono Î¹vâ‚] [mono Î¹vâ‚‚] [mono Î¹hâ‚] [mono Î¹hâ‚‚]
-- variables [epi Ï€vâ‚] [epi Ï€vâ‚‚] [epi Ï€hâ‚] [epi Ï€hâ‚‚]
-- -- of course the diagram should commute
-- variables (sqáµ¤ : fKv â‰« Î¹vâ‚‚ = Î¹vâ‚ â‰« fâ‚)
-- variables (sqâ‚— : Î¹hâ‚ â‰« gâ‚ = gKh â‰« Î¹hâ‚‚) (sqm : fâ‚ â‰« gâ‚‚ = gâ‚ â‰« fâ‚‚)
-- variables (sqáµ£ : Ï€hâ‚ â‰« gQh = gâ‚‚ â‰« Ï€hâ‚‚)
-- variables (sqâ‚› : fâ‚‚ â‰« Ï€vâ‚‚ = Ï€vâ‚ â‰« fQv)

-- include Hâ‚ Hâ‚‚ Vâ‚ Vâ‚‚ sqáµ¤ sqâ‚— sqm sqáµ£ sqâ‚›

-- open_locale zero_object
-- open category_theory.abelian

-- lemma bicartesian.isos_of_isos (hfKv : is_iso fKv) (hfQv : is_iso fQv) :
--   is_iso gKh âˆ§ is_iso gQh :=
-- begin
--   resetI,
--   have mgKh : mono gKh,
--   { have sq : (0 : 0 âŸ¶ Kvâ‚) â‰« Î¹vâ‚ = 0 â‰« Î¹hâ‚ := (is_zero_zero _).eq_of_src _ _,
--     rw (tfae_mono 0 gKh).out 0 2,
--     apply (LBC.three_x_three_left_col _ Hâ‚.pair Hâ‚‚.pair Vâ‚.pair Vâ‚‚.pair
--       sq sqáµ¤ sqâ‚— sqm).1,
--     apply exact_zero_left_of_mono, },
--   have egKh : epi gKh,
--   { exact LBC.four_lemma_left_epi Vâ‚ Vâ‚‚ Hâ‚.pair Hâ‚‚.pair sqáµ¤ sqâ‚— sqm sqâ‚›, },
--   have mgQh : mono gQh,
--   { exact LBC.four_lemma_right_mono Vâ‚ Vâ‚‚ (Hâ‚.drop 1).pair (Hâ‚‚.drop 1).pair sqáµ¤ sqm sqáµ£ sqâ‚›, },
--   have egQh : epi gQh,
--   { have sq : Ï€hâ‚‚ â‰« (0 : _ âŸ¶ 0) = Ï€vâ‚‚ â‰« 0 := (is_zero_zero _).eq_of_tgt _ _,
--     rw (tfae_epi 0 gQh).out 0 2,
--     apply (LBC.three_x_three_right_col
--       (Hâ‚.drop 1).pair (Hâ‚‚.drop 1).pair _ (Vâ‚.drop 1).pair (Vâ‚‚.drop 1).pair
--       sqm sqáµ£ sqâ‚› sq).1,
--     rw â† epi_iff_exact_zero_right, apply_instance },
--   exactI âŸ¨is_iso_of_mono_of_epi _, is_iso_of_mono_of_epi _âŸ©
-- end

-- lemma bicartesian.isos_iff_isos : (is_iso fKv âˆ§ is_iso fQv) â†” (is_iso gKh âˆ§ is_iso gQh) :=
-- begin
--   split; intro h,
--   { apply bicartesian.isos_of_isos fKv gKh gQh fQv Hâ‚ Hâ‚‚ Vâ‚ Vâ‚‚ _ _ _ _ _ h.1 h.2,
--     assumption' },
--   { apply bicartesian.isos_of_isos gKh fKv fQv gQh Vâ‚ Vâ‚‚ Hâ‚ Hâ‚‚ _ _ _ _ _ h.1 h.2;
--     symmetry, assumption' }
-- end
