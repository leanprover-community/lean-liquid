import algebra.homology.additive
import algebra.homology.homological_complex

import for_mathlib.free_abelian_group
import for_mathlib.FreeAb

import breen_deligne.universal_map

/-!

# The category of Breen-Deligne data

This file defines the category whose objects are the natural numbers
and whose morphisms `m ‚ü∂ n` are functorial maps `œÜ_A : ‚Ñ§[A^m] ‚Üí ‚Ñ§[A^n]`.

-/

open_locale big_operators kronecker

namespace breen_deligne

open free_abelian_group category_theory

/-- The category whose objects are natural numbers
and whose morphisms are matrices with integer coefficients. -/
@[derive comm_semiring] def Mat := ‚Ñï

namespace Mat

instance : small_category Mat :=
{ hom := Œª m n, basic_universal_map m n,
  id := basic_universal_map.id,
  comp := Œª l m n f g, basic_universal_map.comp g f,
  id_comp' := Œª n f, basic_universal_map.comp_id,
  comp_id' := Œª n f, basic_universal_map.id_comp,
  assoc' := Œª k l m n f g h, (basic_universal_map.comp_assoc h g f).symm }

end Mat

/-- The category whose objects are natural numbers
and whose morphisms are the free abelian groups generated by
matrices with integer coefficients. -/
@[derive comm_semiring] def FreeMat := ‚Ñï

namespace FreeMat

instance : small_category FreeMat :=
{ hom := Œª m n, universal_map m n,
  id := universal_map.id,
  comp := Œª l m n f g, universal_map.comp g f,
  id_comp' := Œª n f, universal_map.comp_id,
  comp_id' := Œª n f, universal_map.id_comp,
  assoc' := Œª k l m n f g h, (universal_map.comp_assoc h g f).symm }

instance : preadditive FreeMat :=
{ hom_group := Œª m n, infer_instance,
  add_comp' := Œª l m n f g h, add_monoid_hom.map_add _ _ _,
  comp_add' := Œª l m n f g h, show universal_map.comp (g + h) f = _,
    by { rw [add_monoid_hom.map_add, add_monoid_hom.add_apply], refl } }

def to_FreeAbMat : FreeMat ‚•§ FreeAb Mat :=
{ obj := Œª n, FreeAb.of n,
  map := Œª m n f, f,
  map_id' := Œª m, rfl,
  map_comp' := Œª l m n f g, begin
    induction f using free_abelian_group.induction_on;
    try { simp only [limits.zero_comp, preadditive.add_comp, preadditive.neg_comp, *] },
    induction g using free_abelian_group.induction_on;
    try { simp only [limits.comp_zero, preadditive.comp_add, preadditive.comp_neg, *] },
    refl,
  end }

open universal_map

@[simps]
def mul_functor (N : ‚Ñï) : FreeMat ‚•§ FreeMat :=
{ obj := Œª n, N * n,
  map := Œª m n f, mul N f,
  map_id' := Œª n, (free_abelian_group.map_of _ _).trans $ congr_arg _ $
  begin
    dsimp [basic_universal_map.mul, basic_universal_map.id],
    ext i j,
    simp only [matrix.one_kronecker_one, matrix.minor_apply, matrix.one_apply,
      equiv.apply_eq_iff_eq, eq_self_iff_true],
  end,
  map_comp' := Œª l m n f g, mul_comp _ _ _ }
.
instance mul_functor.additive (N : ‚Ñï) : (mul_functor N).additive :=
{ map_add' := Œª m n f g, add_monoid_hom.map_add _ _ _ }

@[simps] def iso_mk' {m n : FreeMat}
  (f : basic_universal_map m n) (g : basic_universal_map n m)
  (hfg : basic_universal_map.comp g f = basic_universal_map.id _)
  (hgf : basic_universal_map.comp f g = basic_universal_map.id _) :
  m ‚âÖ n :=
{ hom := of f,
  inv := of g,
  hom_inv_id' := (comp_of _ _).trans $ congr_arg _ $ hfg,
  inv_hom_id' := (comp_of _ _).trans $ congr_arg _ $ hgf }

def one_mul_iso : mul_functor 1 ‚âÖ ùü≠ _ :=
nat_iso.of_components (Œª n, iso_mk'
  (basic_universal_map.one_mul_hom _) (basic_universal_map.one_mul_inv _)
  basic_universal_map.one_mul_inv_hom basic_universal_map.one_mul_hom_inv)
begin
  intros m n f,
  dsimp,
  show universal_map.comp _ _ = universal_map.comp _ _,
  rw [‚Üê add_monoid_hom.comp_apply, ‚Üê add_monoid_hom.comp_hom_apply_apply,
    ‚Üê add_monoid_hom.flip_apply _ f],
  congr' 1, clear f, ext1 f,
  have : f = matrix.reindex_linear_equiv ‚Ñï _
      ((fin_one_equiv.prod_congr $ equiv.refl _).trans $ equiv.punit_prod _)
      ((fin_one_equiv.prod_congr $ equiv.refl _).trans $ equiv.punit_prod _)
      (1 ‚äó‚Çñ f),
  { ext i j, dsimp [matrix.kronecker, matrix.one_apply],
    simp only [one_mul, if_true, eq_iff_true_of_subsingleton], },
  conv_rhs { rw this },
  simp only [comp_of, mul_of, basic_universal_map.comp, add_monoid_hom.mk'_apply,
    basic_universal_map.mul, basic_universal_map.one_mul_hom,
    add_monoid_hom.comp_hom_apply_apply, add_monoid_hom.comp_apply, add_monoid_hom.flip_apply,
    iso_mk'_hom],
  rw [matrix.reindex_linear_equiv_mul, matrix.reindex_linear_equiv_mul,
    matrix.one_mul, matrix.mul_one],
end

/-
Should `kronecker_reindex_left` and `kronecker_reindex_right` land into `mathlib`?
-/

variables {Œ± Œ≤ Œ≥ : Type*}
variables {l‚ÇÅ m‚ÇÅ n‚ÇÅ l‚ÇÇ m‚ÇÇ n‚ÇÇ : Type*}
variables [fintype l‚ÇÅ] [fintype m‚ÇÅ] [fintype n‚ÇÅ]
variables [fintype l‚ÇÇ] [fintype m‚ÇÇ] [fintype n‚ÇÇ]

lemma kronecker_map_reindex_left (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (el : l‚ÇÅ ‚âÉ l‚ÇÇ) (em : m‚ÇÅ ‚âÉ m‚ÇÇ) (M : matrix l‚ÇÅ m‚ÇÅ Œ±)
  (N : matrix n‚ÇÅ n‚ÇÇ Œ≤) : matrix.kronecker_map f (matrix.reindex el em M) N =
  matrix.reindex (el.prod_congr (equiv.refl _)) (em.prod_congr (equiv.refl _))
  (matrix.kronecker_map f M N) := by { ext ‚ü®i, i'‚ü© ‚ü®j, j'‚ü©, refl }

lemma kronecker_map_reindex_right (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (em : m‚ÇÅ ‚âÉ m‚ÇÇ) (en : n‚ÇÅ ‚âÉ n‚ÇÇ)
  (M : matrix l‚ÇÅ l‚ÇÇ Œ±) (N : matrix m‚ÇÅ n‚ÇÅ Œ≤) :
  matrix.kronecker_map f M (matrix.reindex em en N) =
  matrix.reindex ((equiv.refl _).prod_congr em) ((equiv.refl _).prod_congr en)
    (matrix.kronecker_map f M N) := by { ext ‚ü®i, i'‚ü© ‚ü®j, j'‚ü©, refl }


lemma mul_mul_iso_aux (m n i j : ‚Ñï) (f : basic_universal_map i j) :
  (comp (of (basic_universal_map.mul_mul_hom m n j))) (mul m (mul n (of f))) =
    comp (mul (m * n) (of f)) (of (basic_universal_map.mul_mul_hom m n i)) :=
begin
  simp only [comp_of, mul_of, basic_universal_map.comp, add_monoid_hom.mk'_apply,
    basic_universal_map.mul, basic_universal_map.mul_mul_hom, matrix.mul_reindex_linear_equiv_one],
  rw [matrix.reindex_linear_equiv_mul, matrix.one_mul,
    ‚Üê matrix.reindex_linear_equiv_one ‚Ñï _ (@fin_prod_fin_equiv m n)],
  simp only [matrix.reindex_linear_equiv_apply],
  rw [kronecker_map_reindex_left, kronecker_map_reindex_right, ‚Üê matrix.kronecker_assoc],
  simp only [‚Üê equiv.trans_apply, matrix.reindex_trans, matrix.one_kronecker_one,
    equiv.trans_refl],
  congr' 3, swap 3, { apply_instance },
  { ext ‚ü®‚ü®a, b‚ü©, c‚ü©,
    simp only [equiv.trans_apply, equiv.symm_apply_apply, equiv.apply_symm_apply,
      equiv.prod_assoc_apply, equiv.prod_assoc_symm_apply, equiv.prod_congr_apply,
      prod.map_def, equiv.refl_apply], },
  { ext ‚ü®‚ü®a, b‚ü©, c‚ü©,
    simp only [equiv.trans_apply, equiv.symm_apply_apply, equiv.apply_symm_apply,
      equiv.prod_assoc_apply, equiv.prod_assoc_symm_apply, equiv.prod_congr_apply,
      prod.map_def, equiv.refl_apply, equiv.symm_trans_apply, equiv.symm_symm,
      equiv.prod_congr_symm, equiv.refl_symm], },
end

def mul_mul_iso (m n : ‚Ñï) : mul_functor n ‚ãô mul_functor m ‚âÖ mul_functor (m * n) :=
nat_iso.of_components (Œª i, iso_mk'
  (basic_universal_map.mul_mul_hom m n i) (basic_universal_map.mul_mul_inv m n i)
  basic_universal_map.mul_mul_inv_hom basic_universal_map.mul_mul_hom_inv)
begin
  intros i j f,
  dsimp,
  show universal_map.comp _ _ = universal_map.comp _ _,
  rw [‚Üê add_monoid_hom.comp_apply, ‚Üê add_monoid_hom.comp_apply,
    ‚Üê add_monoid_hom.flip_apply _ (mul (m * n) f),
    ‚Üê add_monoid_hom.comp_apply],
  congr' 1, clear f, ext1 f,
  apply mul_mul_iso_aux,
end

end FreeMat

/-- Roughly speaking, this is a collection of formal finite sums of matrices
that encode the data that rolls out of the Breen--Deligne resolution. -/
@[derive [small_category, preadditive]]
def data := chain_complex FreeMat ‚Ñï

namespace data

variable (BD : data)

section mul

open universal_map

@[simps]
def mul (N : ‚Ñï) : data ‚•§ data :=
(FreeMat.mul_functor N).map_homological_complex _

def mul_one_iso : (mul 1).obj BD ‚âÖ BD :=
homological_complex.hom.iso_of_components (Œª i, FreeMat.one_mul_iso.app _) $
Œª i j _, (FreeMat.one_mul_iso.hom.naturality (BD.d i j)).symm

def mul_mul_iso (m n : ‚Ñï) : (mul m).obj ((mul n).obj BD) ‚âÖ (mul (m * n)).obj BD :=
homological_complex.hom.iso_of_components (Œª i, (FreeMat.mul_mul_iso _ _).app _) $
Œª i j _, ((FreeMat.mul_mul_iso _ _).hom.naturality (BD.d i j)).symm

end mul

/-- `BD.pow N` is the Breen--Deligne data whose `n`-th rank is `2^N * BD.rank n`. -/
def pow' : ‚Ñï ‚Üí data
| 0     := BD
| (n+1) := (mul 2).obj (pow' n)

@[simps] def sum (BD : data) (N : ‚Ñï) : (mul N).obj BD ‚ü∂ BD :=
{ f := Œª n, universal_map.sum _ _,
  comm' := Œª m n _, (universal_map.sum_comp_mul _ _).symm }

@[simps] def proj (BD : data) (N : ‚Ñï) : (mul N).obj BD ‚ü∂ BD :=
{ f := Œª n, universal_map.proj _ _,
  comm' := Œª m n _, (universal_map.proj_comp_mul _ _).symm }

open homological_complex FreeMat category_theory category_theory.limits

def hom_pow' {BD : data} (f : (mul 2).obj BD ‚ü∂ BD) : Œ† N, BD.pow' N ‚ü∂ BD
| 0     := ùüô _
| (n+1) := (mul 2).map (hom_pow' n) ‚â´ f

open_locale zero_object

def pow'_iso_mul : Œ† N, BD.pow' N ‚âÖ (mul (2^N)).obj BD
| 0     := BD.mul_one_iso.symm
| (N+1) := show (mul 2).obj (BD.pow' N) ‚âÖ (mul (2 * 2 ^ N)).obj BD, from
   (mul 2).map_iso (pow'_iso_mul N) ‚â™‚â´ mul_mul_iso _ _ _

lemma hom_pow'_sum : ‚àÄ N, (BD.pow'_iso_mul N).inv ‚â´ hom_pow' (BD.sum 2) N = BD.sum (2^N)
| 0     :=
begin
  ext n : 2,
  simp only [hom_pow', category.comp_id],
  show (BD.pow'_iso_mul 0).inv.f n = (BD.sum 1).f n,
  dsimp only [sum_f, universal_map.sum],
  simp only [fin.default_eq_zero, finset.univ_unique, finset.sum_singleton],
  refine congr_arg of _,
  apply basic_universal_map.one_mul_hom_eq_proj,
end
| (N+1) :=
begin
  dsimp [pow'_iso_mul, hom_pow'],
  slice_lhs 2 3 { rw [‚Üê functor.map_comp, hom_pow'_sum] },
  rw iso.inv_comp_eq,
  ext i : 2,
  iterate 2 { erw [homological_complex.comp_f] },
  dsimp [mul_mul_iso, FreeMat.mul_mul_iso, universal_map.sum],
  rw [universal_map.mul_of],
  show universal_map.comp _ _ = universal_map.comp _ _,
  simp only [universal_map.comp_of, add_monoid_hom.map_sum, add_monoid_hom.finset_sum_apply],
  congr' 1,
  rw [‚Üê finset.sum_product', finset.univ_product_univ, ‚Üê fin_prod_fin_equiv.symm.sum_comp],
  apply fintype.sum_congr,
  apply basic_universal_map.comp_proj_mul_proj,
end
.

lemma hom_pow'_sum' (N : ‚Ñï) : hom_pow' (BD.sum 2) N = (BD.pow'_iso_mul N).hom ‚â´ BD.sum (2^N) :=
by { rw ‚Üê iso.inv_comp_eq, apply hom_pow'_sum }

lemma hom_pow'_proj : ‚àÄ N, (BD.pow'_iso_mul N).inv ‚â´ hom_pow' (BD.proj 2) N = BD.proj (2^N)
| 0     :=
begin
  ext n : 2,
  simp only [hom_pow', category.comp_id],
  show (BD.pow'_iso_mul 0).inv.f n = (BD.proj 1).f n,
  dsimp only [proj_f, universal_map.proj],
  refine congr_arg of _,
  apply basic_universal_map.one_mul_hom_eq_proj,
end
| (N+1) :=
begin
  dsimp [pow'_iso_mul, hom_pow'],
  slice_lhs 2 3 { rw [‚Üê functor.map_comp, hom_pow'_proj] },
  rw iso.inv_comp_eq,
  ext i : 2,
  iterate 2 { erw [homological_complex.comp_f] },
  dsimp [mul_mul_iso, FreeMat.mul_mul_iso, universal_map.proj],
  simp only [add_monoid_hom.map_sum, add_monoid_hom.finset_sum_apply,
    preadditive.comp_sum, preadditive.sum_comp],
  rw [‚Üê finset.sum_comm, ‚Üê finset.sum_product', finset.univ_product_univ,
      ‚Üê fin_prod_fin_equiv.symm.sum_comp],
  apply fintype.sum_congr,
  intros j,
  rw [universal_map.mul_of],
  show universal_map.comp _ _ = universal_map.comp _ _,
  simp only [universal_map.comp_of, basic_universal_map.comp_proj_mul_proj],
end

lemma hom_pow'_proj' (N : ‚Ñï) : hom_pow' (BD.proj 2) N = (BD.pow'_iso_mul N).hom ‚â´ BD.proj (2^N) :=
by { rw ‚Üê iso.inv_comp_eq, apply hom_pow'_proj }

end data

end breen_deligne
