import breen_deligne.universal_map
import breen_deligne.functorial_map
import system_of_complexes.complex

import for_mathlib.free_abelian_group

namespace breen_deligne

open free_abelian_group category_theory

/-- The category whose objects are natural numbers
and whose morphisms are the free abelian groups generated by
matrices with integer coefficients. -/
@[derive comm_semiring] def FreeMat := â„•

namespace FreeMat

instance : small_category FreeMat :=
{ hom := Î» m n, universal_map m n,
  id := universal_map.id,
  comp := Î» l m n f g, universal_map.comp g f,
  id_comp' := Î» n f, universal_map.comp_id,
  comp_id' := Î» n f, universal_map.id_comp,
  assoc' := Î» k l m n f g h, (universal_map.comp_assoc h g f).symm }

instance : preadditive FreeMat :=
{ hom_group := Î» m n, infer_instance,
  add_comp' := Î» l m n f g h, add_monoid_hom.map_add _ _ _,
  comp_add' := Î» l m n f g h, show universal_map.comp (g + h) f = _,
    by { rw [add_monoid_hom.map_add, add_monoid_hom.add_apply], refl } }

open universal_map

lemma double_comp_double {l m n : FreeMat} (f : l âŸ¶ m) (g : m âŸ¶ n) :
  (f.double â‰« g.double : l+l âŸ¶ n+n) = (f â‰« g).double :=
comp_double_double _ _

lemma double_add {m n : FreeMat} (f g : m âŸ¶ n) :
  ((f + g).double : m+m âŸ¶ n+n) = f.double + g.double :=
add_monoid_hom.map_add _ _ _

end FreeMat

/-- Roughly speaking, this is a collection of formal finite sums of matrices
that encode the data that rolls out of the Breen--Deligne resolution. -/
@[derive [small_category, preadditive]]
def data := chain_complex â„• FreeMat

namespace data

variable (BD : data)

/-- `BD.double` is the Breen--Deligne data whose `n`-th rank is `2 * BD.rank n`. -/
@[simps] def double : data :=
{ X := Î» n, BD.X n + BD.X n,
  d := Î» m n, (BD.d m n).double,
  d_eq_zero := Î» m n h, by { rw [BD.d_eq_zero h, universal_map.double_zero] },
  d_comp_d := Î» l m n,
    calc _ = (BD.d l m â‰« BD.d m n).double : universal_map.comp_double_double _ _
    ... = 0 : by { rw [BD.d_comp_d, universal_map.double_zero] } }

/-- `BD.pow N` is the Breen--Deligne data whose `n`-th rank is `2^N * BD.rank n`. -/
def pow : â„• â†’ data
| 0     := BD
| (n+1) := (pow n).double

lemma BD_pow_X : âˆ€ N i, (BD.pow N).X i = 2^N * BD.X i
| 0     i := by { rw [pow_zero, one_mul], refl }
| (N+1) i := by { rw [pow_succ, two_mul, add_mul, â† BD_pow_X N], refl }

@[simps] def Ïƒ : BD.double âŸ¶ BD :=
{ f := Î» n, universal_map.Ïƒ _,
  comm := Î» m n, universal_map.Ïƒ_comp_double _ }

@[simps] def Ï€â‚ : BD.double âŸ¶ BD :=
{ f := Î» n, universal_map.Ï€â‚ _,
  comm := Î» m n, universal_map.Ï€â‚_comp_double _ }

@[simps] def Ï€â‚‚ : BD.double âŸ¶ BD :=
{ f := Î» n, universal_map.Ï€â‚‚ _,
  comm := Î» m n, universal_map.Ï€â‚‚_comp_double _ }

def Ï€ : BD.double âŸ¶ BD := BD.Ï€â‚ + BD.Ï€â‚‚

open differential_object.complex_like FreeMat

@[simps]
def hom_double {BDâ‚ BDâ‚‚ : data} (f : BDâ‚ âŸ¶ BDâ‚‚) : BDâ‚.double âŸ¶ BDâ‚‚.double :=
{ f := Î» i, (f.f i).double,
  comm := Î» i j,
  calc BDâ‚.double.d i j â‰« (f.f j).double
      = (BDâ‚.d i j â‰« f.f j).double : double_comp_double _ _
  ... = (f.f i â‰« BDâ‚‚.d i j).double : congr_arg _ (f.comm i j)
  ... = (f.f i).double â‰« BDâ‚‚.double.d i j : (double_comp_double _ _).symm }

def Ïƒ_pow : Î  N, BD.pow N âŸ¶ BD
| 0     := ğŸ™ _
| (n+1) := hom_double (Ïƒ_pow n) â‰« BD.Ïƒ

def Ï€_pow : Î  N, BD.pow N âŸ¶ BD
| 0     := ğŸ™ _
| (n+1) := hom_double (Ï€_pow n) â‰« BD.Ï€

@[simps]
def homotopy_double {BDâ‚ BDâ‚‚ : data} {f g : BDâ‚ âŸ¶ BDâ‚‚} (h : homotopy f g) :
  homotopy (hom_double f) (hom_double g) :=
{ h := Î» j i, (h.h j i).double,
  h_eq_zero := Î» i j hij, by rw [h.h_eq_zero i j hij, universal_map.double_zero],
  comm := Î» i j k hij hjk,
  begin
    simp only [double_d, double_comp_double, â† double_add, h.comm i j k hij hjk],
    exact add_monoid_hom.map_sub _ _ _
  end }

def homotopy_pow (h : homotopy BD.Ïƒ BD.Ï€) :
  Î  N, homotopy (BD.Ïƒ_pow N) (BD.Ï€_pow N)
| 0     := homotopy.refl
| (n+1) := (homotopy_double (homotopy_pow n)).comp h

open category_theory.limits

/-
=== jmc: I don't think that `reindex` is actually useful
-/

@[simps]
def reindex (rank : â„• â†’ â„•) (hr : âˆ€ i, BD.X i = rank i) :
  data :=
{ X := rank,
  d := Î» i j, (eq_to_iso (hr i)).inv â‰« BD.d i j â‰« (eq_to_iso (hr j)).hom,
  d_comp_d := Î» i j k,
  by simp only [category.assoc, iso.hom_inv_id_assoc, BD.d_comp_d_assoc, zero_comp, comp_zero],
  d_eq_zero := Î» i j hij,
  by simp only [BD.d_eq_zero hij, zero_comp, comp_zero] }

@[simps]
def reindex_iso (rank : â„• â†’ â„•) (hr : âˆ€ i, BD.X i = rank i) :
  BD â‰… BD.reindex rank hr :=
differential_object.complex_like.iso_of_components (Î» i, eq_to_iso (hr i)) $
by { intros i j, rw [reindex_d, iso.hom_inv_id_assoc] }

open universal_map

-- lemma eval_Ïƒ_pow (A : Type*) [add_comm_group A] (N i : â„•) :
--   eval A ((BD.Ïƒ_pow N).f i) = _

end data

section
universe variables u
open universal_map
variables {m n : â„•} (A : Type u) [add_comm_group A] (f : universal_map m n)

end

open differential_object.complex_like

/-- A Breen--Deligne `package` consists of Breen--Deligne `data`
that forms a complex, together with a `homotopy`
between the two universal maps `Ïƒ_add` and `Ïƒ_proj`. -/
structure package :=
(data       : data)
(homotopy   : @homotopy â„• FreeMat ff _ _ _ data.double data data.Ïƒ data.Ï€)

namespace package

/-- `BD.rank i` is the rank of the `i`th entry in the Breen--Deligne resolution described by `BD`. -/
def rank (BD : package) := BD.data.X

def map (BD : package) (i : â„•) := BD.data.d (i+1) i

@[simp] lemma map_comp_map (BD : package) (i : â„•) : BD.map _ â‰« BD.map i = 0 :=
BD.data.d_comp_d _ _ _

end package

end breen_deligne
